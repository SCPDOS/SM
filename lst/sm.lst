     1                                  [DEFAULT REL]
     2                                  BITS 64
     3                                  %include "./src/inc/sm.inc"
     1                              <1> ;Structures and equates for DOSMGR
     2                              <1> 
     3                              <1> SM_SESSION  equ 0       ;Session number for Session Manager
     4                              <1> MAX_TASK    equ 32      ;Maximum of 32 tasks (0-31)
     5                              <1> MAX_SCHED   equ 31      ;Maximum Schedule number (31)
     6                              <1> NUM_SCHED   equ MAX_SCHED + 1   ;Number of schedules
     7                              <1> 
     8                              <1> ;Critical Lock
     9                              <1> struc critLock
    10 00000000 ????????            <1>     .dCount     dd ?    ;When this is zero, the lock is free
    11 00000004 ????????????????    <1>     .pOwnerPcb  dq ?    ;Ptr to the owner of the lock!
    12                              <1> endstruc
    13                              <1> 
    14                              <1> ;System Object Table header
    15                              <1> struc soth  
    16 00000000 ????????????????    <1>     .pNextSoth  dq ?    ;Ptr to the next soth (-1 means end of chain)
    17 00000008 ????????            <1>     .dNumEntry  dd ?    ;Number of entries in this SOTH
    18 0000000C ????                <1>     .wObjType   dw ?    ;Type of object stored in the table
    19 0000000E ????                <1>     .wObjectSz  dw ?    ;Size of the objects stored in this table
    20                              <1> endstruc
    21                              <1> 
    22                              <1> OBJ_HDL     equ 0   ;A handle table header
    23                              <1> OBJ_PCB     equ 1   ;A PCB table header
    24                              <1> OBJ_PTDA    equ 2   ;A PTDA table header
    25                              <1> 
    26                              <1> ;Schedule head, no lock as in a multiprocessor system we have a schedule
    27                              <1> ; block per processor and don't share threads (for simplicity, for now).
    28                              <1> ; We can introduce an atomic xfer system later.
    29                              <1> struc schedHead
    30 00000000 ????????            <1>     .dNumEntry  dd ?    ;Number of entries in this schedule
    31 00000004 ????????????????    <1>     .pSchedHead dq ?    ;Ptr to next ptda in schedule to be executed
    32 0000000C ????????????????    <1>     .pSchedTail dq ?    ;Ptr to last ptda in schedule
    33                              <1> endstruc
    34                              <1> 
    35                              <1> 
    36                              <1> 
    37                              <1> ;Per-task (thread) data area, keeps task (thread) state, including the 
    38                              <1> ; entries modified by the scheduler!
    39                              <1> struc ptda 
    40                              <1> ;The following variable IS ONLY touched by the scheduler.
    41                              <1> ;It is meaningless w/o a schedule lock!
    42 00000000 ????????????????    <1>     .pNSchdPtda dq ?   ;Points to the next ptda in the schedule
    43                              <1> ;Here begins the actual PTDA.
    44 00000008 ????????????????    <1>     .pPcb       dq ?    ;Ptr to the owning pcb (process)
    45 00000010 ????????????????    <1>     .pNProcPtda dq ?    ;Ptr to the next ptda owned by the process
    46 00000018 ??                  <1>     .bState     db ?    ;State of the thread
    47                              <1> ;Sleep and Blocking States
    48 00000019 ??                  <1>     .bSleepStat db ?    ;If set, sleep can be interrupted
    49 0000001A ????????????????    <1>     .pNSlepPtda dq ?    ;Ptr to the next ptda in the sleep chain
    50 00000022 ????????            <1>     .dSleepLen  dd ?    ;Sleep length in ~ms, 0 mean indefinite
    51 00000026 ????????            <1>     .dAwakeCode dd ?    ;Non-zero codes indicating why task was woken up
    52 0000002A ????????????????    <1>     .qEventId   dq ?    ;ID to check for block/run calls.
    53                              <1> ;Register storage
    54 00000032 ????????????????    <1>     .qRSP       dq ?    ;RSP on task switch
    55 0000003A <res 80h>           <1>     .sRegsTbl   dq 16 dup (?)   ;Register storage location
    56                              <1>     .boS:
    57                              <1>     ;alignb 16
    58                              <1>     ;.pFPUState  dq 512 dup (?)  ;Extended state storage
    59                              <1> ;Per-process DOS state
    60                              <1>     .sdaCopy:           ;Copy of the DOS sda for this session when not active
    61                              <1> endstruc
    62                              <1> 
    63                              <1> ;Thread awakening states. Used to indicate why a thread was brought out of 
    64                              <1> ; waiting to a standby/ready state
    65                              <1> AWAKE_NORMAL        equ 0   ;Normal task awake code
    66                              <1> AWAKE_TIMEOUT       equ 1   ;Task was awoken by timeout
    67                              <1> AWAKE_INTER         equ 2   ;Task was interrupted
    68                              <1> AWAKE_STARVING      equ 3   ;Awoken by scheduler because system was starving
    69                              <1> 
    70                              <1> ;Thread states
    71                              <1> THREAD_INIT         equ 0   ;When we allocate the thread block.
    72                              <1> ;When we allocate a thread block, we clear the struct to zero hence this value
    73                              <1> THREAD_READY        equ 1   ;Ready to run on current h/w thread.
    74                              <1> ;A thread in this state is in the ready queue for the selected priority for 
    75                              <1> ; the selected hw thread.
    76                              <1> THREAD_RUNNING      equ 2   ;Currently running thread!
    77                              <1> THREAD_STANDBY      equ 3   ;Next thread to run on a particular hw thrd
    78                              <1> ;Threads in STANDBY can be preempted by higher priority thread if one 
    79                              <1> ; becomes available. If this is the case the thread is returned back to ready
    80                              <1> ; and the next "second to run" thread is set to standby.
    81                              <1> THREAD_TERMINATED   equ 4   ;Set if thread awaits reaping (a CWAIT call).
    82                              <1> THREAD_WAITING      equ 5   ;Contains specific informaing in wait fields
    83                              <1> ;When a thread is blocked due to devblk or sleep this is the state the 
    84                              <1> ; thread is stored in. More info is set in the waiting metadata field.
    85                              <1> THREAD_TRANSITION   equ 6   ;NOT USED, waiting for Stack to be paged in
    86                              <1> THREAD_DEF_READY    equ 7   ;Ready to run, need to allocate to h/w thread
    87                              <1> ;Deferred ready processes are waiting to be allocated to a hw thread.
    88                              <1> ; Once a process is ready w/o a hw thread this gets set and then we 
    89                              <1> ; select a hw thread to run on. Currently there is only one. Thus this
    90                              <1> ; will only ever be seen when a process is coming out of INIT.
    91                              <1> THREAD_GATE_WAITING equ 8   ;Waiting on a special kernel object (Crit 1/2)
    92                              <1> ;Needed to indicate that we are not in a normal wait and that this thread
    93                              <1> ; is to wait until a kernel lock is freed.
    94                              <1> 
    95                              <1> ;Process control block, keeps full process state.
    96                              <1> ;Must be aligned in size to 16 bytes.
    97                              <1> struc pcb  
    98 00000000 ??                  <1>     .bPcbInUse  db ?    ;Set if this PCB is allocated
    99                              <1> ;Process metadata
   100 00000001 ????????            <1>     .hPcb       dd ?    ;Hdl to this pcb
   101 00000005 ????????            <1>     .hParPcb    dd ?    ;Handle to the parent pcb
   102 00000009 ????????            <1>     .dCsid      dd ?    ;CSID of this task chain (id of root program)
   103 0000000D ????????            <1>     .hScrnNum   dd ?    ;Handle to the session (byte number of the screen)
   104 00000011 ????                <1>     .wFlags     dw ?    ;Process flags
   105                              <1> ;PTDA block, refers to PTDA 0 for this process
   106 00000013 <res Dh>            <1>     alignb 10h
   107 00000020 <res BAh>           <1>     .sPtda      db ptda_size dup (?) ;Thread 0's PTDA
   108                              <1> ;Interrupt handles for replacing on task swap
   109 000000DA ????????????????    <1>     .pInt22h    dq ?    ;Int 22h handler on task switch
   110 000000E2 ????????????????    <1>     .pInt23h    dq ?    ;Int 23h handler on task switch
   111 000000EA ????????????????    <1>     .pInt24h    dq ?    ;Int 24h handler on task switch
   112 000000F2 ????????????????    <1>     .pInt2Eh    dq ?    ;Int 2Eh handler on task switch (for master CMD)
   113                              <1> endstruc
   114                              <1> 
   115                              <1> 
   116                              <1> ;Communication packet with MCON
   117                              <1> 
   118                              <1> struc mScrCap  
   119 00000000 ????                <1>     .wVer       dw ?    ;Upper byte, Major num (1). Lower byte, minor num (0)
   120 00000002 ????                <1>     .wLen       dw ?    ;Length of structure (13 bytes)
   121 00000004 ??                  <1>     .bScrNum    db ?    ;Number of screens supported by driver
   122 00000005 ????????????????    <1>     .pDevHlp    dq ?    ;Pointer to the devHlp help routine
   123                              <1> endstruc
   124                              <1> 
   125                              <1> magicCode equ 7100h ;Scancode/ASCII code of ALT+F10
   126                              <1> 
   127                              <1> DevHlp_ConsInputFilter  equ 5
   128                              <1> DevHlp_Signal_SM        equ 7
   129                              <1> DevHlp_ProcBlock        equ 9
   130                              <1> DevHlp_ProcRun          equ 10
   131                              <1> DevHlp_GetDOSVar        equ 16
   132                              <1> 
   133                              <1> 
   134                              <1> ;BIOS Equates go here
   135                              <1> EOI         equ 20h
   136                              <1> pic1cmd     equ 20h
   137                              <1> 
   138                              <1> PITbase     equ 40h
   139                              <1> PIT0        equ PITbase
   140                              <1> PIT1        equ PITbase + 1
   141                              <1> PIT2        equ PITbase + 2
   142                              <1> PITcmd      equ PITbase + 3
   143                              <1> 
   144                              <1> timerInt    equ 0F0h    ;Change if we change this in BIOS!!
     4                                  %include "./src/inc/dosStruc.inc"
     1                              <1> ;Structures and equates coming from DOS
     2                              <1> 
     3                              <1> ;Load program structure
     4                              <1> struc loadProg
     5 00000000 ????????????????    <1>     .pEnv       resq 1  ;Ptr to environment block (or 0 => copy parent env)
     6 00000008 ????????????????    <1>     .pCmdLine   resq 1  ;Ptr to the command line to be placed at PSP + 80h
     7 00000010 ????????????????    <1>     .pfcb1      resq 1  ;Ptr to the first FCB (parsed argument 1)
     8 00000018 ????????????????    <1>     .pfcb2      resq 1  ;Ptr to the second FCB  (parsed argument 2)
     9 00000020 ????????????????    <1>     .initRSP    resq 1  ;Return the start value for rsp
    10 00000028 ????????????????    <1>     .initRIP    resq 1  ;Return the entry point for the task
    11                              <1> endstruc
    12                              <1> 
    13                              <1> ;Sysvars struct
    14                              <1> drvHdr_size equ 022h
    15                              <1> struc sysVars
    16 00000000 ????????????????    <1>     .dpbHeadPtr  dq ?    
    17 00000008 ????????????????    <1>     .sftHeadPtr  dq ?    
    18 00000010 ????????????????    <1>     .clockPtr    dq ?    
    19 00000018 ????????????????    <1>     .vConPtr     dq ?
    20 00000020 ????                <1>     .maxBytesSec dw ?    
    21 00000022 ????????????????    <1>     .bufHeadPtr  dq ?    
    22 0000002A ????????????????    <1>     .cdsHeadPtr  dq ?    
    23 00000032 ????????????????    <1>     .fcbsHeadPtr dq ?    
    24 0000003A ????                <1>     .numSafeSFCB dw ?    
    25 0000003C ??                  <1>     .numPhysVol  db ?    
    26 0000003D ??                  <1>     .lastdrvNum  db ?
    27 0000003E ??                  <1>     .numBuffers  db ?
    28 0000003F <res 22h>           <1>     .nulDevHdr   db drvHdr_size dup (?)
    29 00000061 ??                  <1>     .numJoinDrv  db ?    
    30 00000062 ??                  <1>     .numFiles    db ?   
    31                              <1> ; ---- dosMgrHooks and fun stuff ----
    32 00000063 ??                  <1>     .dosMgrPresent  db ?    ;Clear if no mgr, else set to -1
    33 00000064 ????????????????    <1>     .launchTask     dq ?    ;Registers a new task
    34 0000006C ????????????????    <1>     .terminateTask  dq ?    ;Called to tell the MGR that this task is ending
    35                              <1> endstruc
    36                              <1> 
    37                              <1> struc sda
    38                              <1> ;Only the fields that we care about are here. These live in the 
    39                              <1> ; "always swap" portion of the SDA
    40                              <1> ;We only really care about inDOS, errorLevel and currentPSP
    41 00000000 ??                  <1>     .critErrFlag db ?  ;Critical error flag, set on entry to Int 24h x
    42 00000001 ??                  <1>     .inDOS       db ?  ;Inc on each DOS call, dec when leaving x
    43 00000002 ??                  <1>     .errorDrv    db ?  ;Drive on which error occured or FFh x
    44 00000003 ??                  <1>     .errorLocus  db ?  ;Where the error took place  
    45 00000004 ????                <1>     .errorExCde  dw ?  ;Extended Error Code
    46 00000006 ??                  <1>     .errorAction db ?  ;Suggested action for error  
    47 00000007 ??                  <1>     .errorClass  db ?  ;Error Class
    48 00000008 ????????????????    <1>     .xInt24RDI   dq ?  ;Preserved rdi across a critical error
    49 00000010 ????????????????    <1>     .currentDTA  dq ?  ;Address of the current DTA x
    50 00000018 ????????????????    <1>     .currentPSP  dq ?  ;Address of current PSP x
    51                              <1> 
    52 00000020 ????????????????    <1>     .xInt23hRSP  dq ?  ;Saves RSP across an Int 23h call
    53 00000028 ????                <1>     .errorLevel  dw ?  ;Last return code returned by Int 21h/4Ch x
    54                              <1>     ;Upper byte: 0=Normal, 1=Abort Occured, 2=CtrlC, 3=TSR 41h/31h
    55                              <1>     ;Lower byte: User Specified
    56 0000002A ??                  <1>     .currentDrv  db ?  ;Default drive x
    57 0000002B ??                  <1>     .breakFlag   db ?  ;If set, check for CTRL+C on all DOS calls x
    58                              <1> endstruc
    59                              <1> 
    60                              <1> dfltJFTsize equ 20  ;Default size of PSP JFT
    61                              <1> struc psp
    62 00000000 ????                <1>     .return     db 2 dup (?)  ;Should always be CDh 20h, same place as DOS
    63 00000002 ????????            <1>     .allocSize  dd ?  ;Number of paras in init alloc or when exiting as TSR.
    64 00000006 ????????            <1>                 dd ?  ;Reserved 4 bytes
    65 0000000A ????????????????    <1>     .oldInt22h  dq ?  ;Int 22h pointer on overlay load
    66 00000012 ????????????????    <1>     .oldInt23h  dq ?  ;Int 23h pointer on overlay load
    67 0000001A ????????????????    <1>     .oldInt24h  dq ?  ;Int 24h pointer on overlay load
    68 00000022 ????????????????    <1>     .parentPtr  dq ?  ;Pointer to parent process PSP
    69                              <1> ;If jftSize > 20, then the QWORD at .jobFileTbl becomes a pointer
    70                              <1> ; to the actual in use JFT and the other 12 bytes are left undefined.
    71                              <1> ;If jftSize < 20 (DOS will never set it so), then it is considered as 20
    72                              <1> ;If the user tries to reduce handle count to 20 or less, then the PSP JFT is 
    73                              <1> ; always used and jftSize.
    74                              <1>     .externalJFTPtr:    ;Ptr to external JFT array (first byte AFTER MCB)
    75 0000002A <res 14h>           <1>     .jobFileTbl db dfltJFTsize dup (?) ;Main File handle array, JFT
    76 0000003E ????????????????    <1>     .envPtr     dq ?  ;Pointer to the environment
    77 00000046 ????????????????    <1>     .rspPtr     dq ?  ;Pointer to rsp on entry to Int 21h
    78 0000004E ????                <1>     .jftSize    dw ?  ;JFT array size, 20 => PSP JFT in use
    79 00000050 ??????              <1>     .unixEntry  db 3 dup (?)  ;Must always be CDh 21h CBh, same place as DOS
    80 00000053 ????????????????    <1>     .prevPSP    dq ?  ;Pointer to the previous PSP in chain (used by SHARE)
    81 0000005B ??                  <1>                 db ?  ;Reserved byte
    82                              <1> ;The below are in the same place as in DOS.
    83                              <1>     .cmdLineArgPtr: ;Symbol for future use
    84 0000005C <res 10h>           <1>     .fcb1       db 16 dup (?)  ;First FCB,    argument 1 
    85 0000006C <res 14h>           <1>     .fcb2       db 20 dup (?)  ;Second FCB,   argument 2
    86                              <1>     .dta:   ;Pointer to the default DTA in the PSP
    87 00000080 ??                  <1>     .parmList   db ?   ;Number of characters in command tail
    88 00000081 <res 7Fh>           <1>     .progTail   db 127 dup (?) ;Default DTA/Program tail
    89                              <1> endstruc
    90                              <1> 
    91                              <1> struc callerFrame
    92 00000000 ????????????????    <1>     .rax    dq ?  ;Bottom of frame, pointer to rax saved in oldRSP
    93 00000008 ????????????????    <1>     .rbx    dq ?    
    94 00000010 ????????????????    <1>     .rcx    dq ?
    95 00000018 ????????????????    <1>     .rdx    dq ?
    96 00000020 ????????????????    <1>     .rsi    dq ?
    97 00000028 ????????????????    <1>     .rdi    dq ?
    98 00000030 ????????????????    <1>     .rbp    dq ?
    99 00000038 ????????????????    <1>     .r8     dq ?  ;To be removed if truly not needed
   100 00000040 ????????????????    <1>     .r9     dq ?
   101                              <1> ;Pushed by Processor when invoked via Interrupt
   102 00000048 ????????????????    <1>     .rip    dq ?
   103 00000050 ????????????????    <1>     .cs     dq ?
   104 00000058 ????????????????    <1>     .flags  dq ?
   105 00000060 ????????????????    <1>     .rsp    dq ?
   106 00000068 ????????????????    <1>     .ss     dq ?
   107                              <1> endstruc
   108                              <1> 
   109                              <1> execLoadGo  equ 0
   110                              <1> execLoad    equ 1
   111                              <1> execInvld   equ 2
   112                              <1> execOverlay equ 3
   113                              <1> execBkgrnd  equ 4
   114                              <1> 
   115                              <1> struc execFrame
   116 00000000 ????????????????    <1>     .oldRBP     dq ?  
   117 00000008 ????????????????    <1>     .bSubFunc   dq ?  ;Subfunction number
   118 00000010 ????????????????    <1>     .wProgHdl   dq ?  ;File handle number for executable file
   119 00000018 ????????????????    <1>     .wNameLen   dq ?  ;Needs to be less than 64 but welp
   120 00000020 ????????????????    <1>     .pParam     dq ?  ;Parameter list pointer
   121 00000028 ????????????????    <1>     .pProgname  dq ?  ;Ptr to ASCIIZ program name
   122                              <1> 
   123 00000030 ????????????????    <1>     .pEnvBase   dq ?  ;Ptr to new Environment block, NOT THE MCB FOR ENV BLK
   124 00000038 ????????????????    <1>     .pPSPBase   dq ?  ;Ptr to new PSP base address
   125 00000040 ????????????????    <1>     .pProgBase  dq ?  ;Ptr to Prog. Base addr., ALIGNED FOR FIRST EXE SECTION
   126 00000048 ????????????????    <1>     .dProgSize  dq ?  ;Program size is saved here, PSP included.
   127 00000050 ????????????????    <1>     .dCOFFhdr   dq ?  ;Offset in file to COFF header. Set to 0 for COM
   128 00000058 ????????????????    <1>     .bSegCount  dq ?  ;Count of segments loaded into memory
   129 00000060 ????????????????    <1>     .wCOFFChars dq ?  ;Save the COFF characteristics in here
   130                              <1> .pProgEP:   ;Program EP, recycle this qword
   131 00000068 ????????????????    <1>     .wNumSeg    dq ?  ;Number of segments, consider reusing NameLen
   132 00000070 ????????????????    <1>     .dFilePtr   dq ?  ;Keep of track of where in file we are
   133 00000078 ????????????????    <1>     .qRelocVal  dq ?  ;Used when computing relocations, Rebasing factor
   134                              <1> endstruc
   135                              <1> 
   136                              <1> ;MISC ASCII control chars
   137                              <1> NUL equ 00h ;^@         | ASCII Null
   138                              <1> ETX equ 03h ;^C         | ASCII Break (End of Text)
   139                              <1> ACK equ 06h ;^F         | ASCII Acknowledgement
   140                              <1> BEL equ 07h ;^G         | ASCII Bell
   141                              <1> BSP equ 08h ;^H         | ASCII Backspace
   142                              <1> TAB equ 09h ;^I         | ASCII Horizontal Tab
   143                              <1> LF  equ 0Ah ;^J         | ASCII Line Feed
   144                              <1> CR  equ 0Dh ;^M         | ASCII Carriage Return
   145                              <1> DLE equ 10h ;^P         | ASCII Data Link End (Toggle Print Echo)
   146                              <1> DC3 equ 13h ;^S         | ASCII Device Control 3 (Toggle Scroll Lock)
   147                              <1> DC4 equ 14h ;^T         | ASCII Device Control 4
   148                              <1> NAK equ 15h ;^U         | ASCII Negative Acknowledgement
   149                              <1> CMD equ 16h ;^V         | EDLIN COMMAND CHAR
   150                              <1> ETB equ 17h ;^W         | ASCII End of Transmission Block
   151                              <1> EOF equ 1Ah ;^Z         | ASCII Substitute character (End of File)
   152                              <1> ESC equ 1Bh ;           | ASCII Escape char, used for ANSI.SYS
   153                              <1> SPC equ 20h ;Printable  | ASCII Space
   154                              <1> ;This last one is NEVER printed with a caret as it is a console control char
   155                              <1> DEL equ 7Fh ;^?         | ASCII Rubout (Del char and dec cursor)
   156                              <1> 
   157                              <1> asciiCaret  equ 20h ;Used to check which chars need to be printed with caret
   158                              <1> asciiMask   equ asciiCaret - 1  ;Turn into a bitmask
   159                              <1> 
   160                              <1> ;Extended Ascii Codes
   161                              <1> eF1     equ 3Bh ;F1 second byte
   162                              <1> eF2     equ 3Ch ;F2 second byte
   163                              <1> eF3     equ 3Dh ;F3 second byte
   164                              <1> eF4     equ 3Eh ;F4 second byte
   165                              <1> eF5     equ 3Fh ;F5 second byte
   166                              <1> eF6     equ 40h ;F6 second byte
   167                              <1> eF7     equ 41h ;F7 second byte
   168                              <1> eCursL  equ 4Bh ;Cursor Left second byte
   169                              <1> eCursR  equ 4Dh ;Cursor Right second byte
   170                              <1> eIns    equ 52h ;Insert second byte
   171                              <1> eDel    equ 53h ;DEL second byte (not necessarily delete key)
     5                                  %include "./src/inc/drvStruc.inc"
     1                              <1> 
     2                              <1> ;-------------------------------------------------------;
     3                              <1> ; This include file contains miscellaneous SCP/DOS      ;
     4                              <1> ; device driver related structures.                     ;
     5                              <1> ;-------------------------------------------------------;
     6                              <1> 
     7                              <1> struc drvHdr  ;Device Driver Header for character and block devices
     8                              <1> 
     9 00000000 ????????????????    <1>     .nxtPtr dq ?  ;Pointer to the next driver header, -1 if at the end
    10 00000008 ????                <1>     .attrib dw ?  ;Attribute Word
    11 0000000A ????????????????    <1>     .strPtr dq ?  ;Strategy Entry Pointer
    12 00000012 ????????????????    <1>     .intPtr dq ?  ;Interrupt Entry Pointer
    13                              <1>     .drvUnt:        ;Number of units pointer
    14 0000001A ????????????????    <1>     .drvNam db 8 dup (?)  ;Driver name (Char) or Number of units byte (Block)
    15                              <1> 
    16                              <1> endstruc
    17                              <1> 
    18                              <1> ;Command Code equates
    19                              <1>     drvINIT         equ 0
    20                              <1>     drvMEDCHK       equ 1
    21                              <1>     drvBUILDBPB     equ 2
    22                              <1>     drvIOCTLREAD    equ 3
    23                              <1>     drvREAD         equ 4
    24                              <1>     drvNONDESTREAD  equ 5
    25                              <1>     drvINSTATUS     equ 6
    26                              <1>     drvFLUSHINBUF   equ 7
    27                              <1>     drvWRITE        equ 8
    28                              <1>     drvWRITEVERIFY  equ 9
    29                              <1>     drvOUTSTATUS    equ 10
    30                              <1>     drvFLUSHOUTBUF  equ 11
    31                              <1>     drvIOCTLWRITE   equ 12
    32                              <1>     drvOPEN         equ 13
    33                              <1>     drvCLOSE        equ 14
    34                              <1>     drvREMMEDCHECK  equ 15
    35                              <1>     drvOUTTILBUSY   equ 16  ;Not implemented
    36                              <1>     drvIOCTL        equ 19
    37                              <1>     drvStopCon      equ 20  ; NEW MULTITASKING 
    38                              <1>     drvRestartCon   equ 21  ; NEW MULTITASKING
    39                              <1>     drvGETDRVMAP    equ 23
    40                              <1>     drvSETDRVMAP    equ 24
    41                              <1>     
    42                              <1> ;Driver Error equates 
    43                              <1>     drvWPErr        equ 0   ;Write Protect Violation
    44                              <1>     drvBadUnit      equ 1   ;Unknown unit
    45                              <1>     drvNotReady     equ 2   ;Device not ready
    46                              <1>     drvBadCmd       equ 3   ;Unknown command
    47                              <1>     drvCRCErr       equ 4   ;CRC Error
    48                              <1>     drvBadDrvReq    equ 5   ;Bad drive request structure length
    49                              <1>     drvBadSeek      equ 6   ;Seek error
    50                              <1>     drvBadMed       equ 7   ;Unknown media
    51                              <1>     drvSecNotFnd    equ 8   ;Sector not found
    52                              <1>     drvNoPaper      equ 9   ;Printer out of paper
    53                              <1>     drvWriteFault   equ 10  ;Write Fault
    54                              <1>     drvReadFault    equ 11  ;Read Fault
    55                              <1>     drvGenFault     equ 12  ;General Fault
    56                              <1>     drvBadDskChnge  equ 15  ;Invalid disk change
    57                              <1> 
    58                              <1> ;Driver status word status bit meanings
    59                              <1>     drvErrStatus    equ 8000h  
    60                              <1>     drvDonStatus    equ 0100h
    61                              <1>     drvBsyStatus    equ 0200h
    62                              <1> 
    63                              <1> ;Driver Attribute Word bit meanings
    64                              <1>     devDrvConIn    equ 1h  ;If set, device is CON input
    65                              <1>     devDrvConOut   equ 2h  ;If set, device is CON output
    66                              <1>     devDrvNulDev   equ 4h  ;If set, device is NULL device
    67                              <1>     devDrvClockDev equ 8h  ;If set, device is CLOCK device
    68                              <1>     devDrvFastOut  equ 10h ;If set, device supports Int 29h
    69                              <1>     devDrvMulti    equ 20h ;Reserved, If set, device is multitasking. 
    70                              <1>     devDrvIOCTL    equ 40h ;If set, IOCTL and GET/SET suported
    71                              <1>     devDrvHdlCTL   equ 800h ;If set, Open, Close and Rem media supported
    72                              <1>     devDrvIOCTLRW  equ 4000h ;If set, IOCTL Read/Write supported
    73                              <1>     devDrvChar     equ 8000h ;If set, Char device
    74                              <1> ;Bit 0 1=console input
    75                              <1> ;    1 1=console output (character devices)
    76                              <1> ;    2 1=NUL device
    77                              <1> ;    3 1=CLOCK device
    78                              <1> ;    4 1=Int 29 output (CON)
    79                              <1> ;    5 1=Multitasking driver. Bit ignored by DOS. Used by multitaskers.
    80                              <1> ; If bit set, no crit2 lock placed on thread when making drv request.
    81                              <1> ;    6 1=extended functions supported (13,17,18) (3.2+)
    82                              <1> ;    7 1=Generic IOCTL function supported (19)
    83                              <1> ;   11 1=open/close/removable media supported (3.0+)
    84                              <1> ;   13 1=output until busy supported (character devices) (3.0+)
    85                              <1> ;      1=media descriptor in FAT required (block devices)
    86                              <1> ;   14 1=IOCTL R/W supported
    87                              <1> ;   15 0=block device
    88                              <1> ;      1=character device
    89                              <1> 
    90                              <1> ;Driver structures
    91                              <1> 
    92                              <1> %macro drvReqHdrM 0 ;Driver Request Header Macro
    93                              <1> 
    94                              <1>     .hdrlen db ?  ;Length of the request header
    95                              <1>     .unitnm db ?  ;Unit number, meaningless for character devs
    96                              <1>     .cmdcde db ?  ;Command code
    97                              <1>     .status dw ?  ;Status word
    98                              <1>     .devptr dq ?  ;Device queue pointer field, reserved for future use
    99                              <1> 
   100                              <1> %endmacro
   101                              <1> 
   102                              <1> struc drvReqHdr
   103                              <1>     drvReqHdrM
    93                              <2> 
    94 00000000 ??                  <2>  .hdrlen db ?
    95 00000001 ??                  <2>  .unitnm db ?
    96 00000002 ??                  <2>  .cmdcde db ?
    97 00000003 ????                <2>  .status dw ?
    98 00000005 ????????????????    <2>  .devptr dq ?
    99                              <2> 
   104                              <1> endstruc
   105                              <1> 
   106                              <1> struc initReqPkt  ;Init Request Packet
   107                              <1> 
   108                              <1>     drvReqHdrM   ;Common Driver Header Macro
    93                              <2> 
    94 00000000 ??                  <2>  .hdrlen db ?
    95 00000001 ??                  <2>  .unitnm db ?
    96 00000002 ??                  <2>  .cmdcde db ?
    97 00000003 ????                <2>  .status dw ?
    98 00000005 ????????????????    <2>  .devptr dq ?
    99                              <2> 
   109 0000000D ??                  <1>     .numunt db ?  ;Number of logical units (Block only, 0 for char)
   110 0000000E ????????????????    <1>     .endptr dq ?  ;Pointer to first free byte after driver
   111 00000016 ????????????????    <1>     .optptr dq ?  ;Ptr to BPB array (blkdev) or cmdline args
   112 0000001E ??                  <1>     .drvnum db ?  ;First Drive number
   113                              <1> 
   114                              <1> endstruc
   115                              <1> 
   116                              <1> struc mediaCheckReqPkt ;Media Check Request Packet
   117                              <1> 
   118                              <1>     drvReqHdrM    ;Common Driver Header Macro
    93                              <2> 
    94 00000000 ??                  <2>  .hdrlen db ?
    95 00000001 ??                  <2>  .unitnm db ?
    96 00000002 ??                  <2>  .cmdcde db ?
    97 00000003 ????                <2>  .status dw ?
    98 00000005 ????????????????    <2>  .devptr dq ?
    99                              <2> 
   119 0000000D ??                  <1>     .medesc db ?  ;DOS media descriptor
   120 0000000E ??                  <1>     .medret db ?  ;Return byte (Has media been changed?)
   121 0000000F ????????????????    <1>     .desptr dq ?  ;Pointer to a valid volume id field
   122                              <1> 
   123                              <1> endstruc
   124                              <1> 
   125                              <1> struc bpbBuildReqPkt  ;Build BPB Request Packet
   126                              <1> 
   127                              <1>     drvReqHdrM    ;Common Driver Header Macro
    93                              <2> 
    94 00000000 ??                  <2>  .hdrlen db ?
    95 00000001 ??                  <2>  .unitnm db ?
    96 00000002 ??                  <2>  .cmdcde db ?
    97 00000003 ????                <2>  .status dw ?
    98 00000005 ????????????????    <2>  .devptr dq ?
    99                              <2> 
   128 0000000D ??                  <1>     .medesc db ?  ;DOS media descriptor
   129 0000000E ????????????????    <1>     .bufptr dq ?  ;Transfer buffer
   130 00000016 ????????????????    <1>     .bpbptr dq ?  ;Pointer to the BPB
   131                              <1> 
   132                              <1> endstruc
   133                              <1> 
   134                              <1> struc ioReqPkt   ;IO Request Packet
   135                              <1> 
   136                              <1>     drvReqHdrM    ;Common Driver Header Macro
    93                              <2> 
    94 00000000 ??                  <2>  .hdrlen db ?
    95 00000001 ??                  <2>  .unitnm db ?
    96 00000002 ??                  <2>  .cmdcde db ?
    97 00000003 ????                <2>  .status dw ?
    98 00000005 ????????????????    <2>  .devptr dq ?
    99                              <2> 
   137 0000000D ??                  <1>     .medesc db ?  ;DOS media descriptor
   138 0000000E ????????????????    <1>     .bufptr dq ?  ;Transfer buffer
   139 00000016 ????????            <1>     .tfrlen dd ?  ;Number of Sectors/bytes to transfer
   140 0000001A ????????????????    <1>     .strtsc dq ?  ;Starting sector for transfer
   141 00000022 ????????????????    <1>     .desptr dq ?  ;Pointer to a valid volume id field if error
   142                              <1> 
   143                              <1> endstruc
   144                              <1> 
   145                              <1> struc ndInNoWaitPkt    ;Nondestructive Input No Wait Request Packet
   146                              <1>     
   147                              <1>     drvReqHdrM    ;Common Driver Header Macro
    93                              <2> 
    94 00000000 ??                  <2>  .hdrlen db ?
    95 00000001 ??                  <2>  .unitnm db ?
    96 00000002 ??                  <2>  .cmdcde db ?
    97 00000003 ????                <2>  .status dw ?
    98 00000005 ????????????????    <2>  .devptr dq ?
    99                              <2> 
   148 0000000D ??                  <1>     .retbyt db ?  ;Byte read non destructively
   149                              <1> 
   150                              <1> endstruc
   151                              <1> 
   152                              <1> struc statusReqPkt   ;Status Request Packet
   153                              <1> 
   154                              <1>     drvReqHdrM    ;Common Driver Header Macro
    93                              <2> 
    94 00000000 ??                  <2>  .hdrlen db ?
    95 00000001 ??                  <2>  .unitnm db ?
    96 00000002 ??                  <2>  .cmdcde db ?
    97 00000003 ????                <2>  .status dw ?
    98 00000005 ????????????????    <2>  .devptr dq ?
    99                              <2> 
   155                              <1> 
   156                              <1> endstruc
   157                              <1> 
   158                              <1> struc flushReqPkt ;Flush Request Packet, terminate all pending requests
   159                              <1> 
   160                              <1>     drvReqHdrM    ;Common Driver Header Macro
    93                              <2> 
    94 00000000 ??                  <2>  .hdrlen db ?
    95 00000001 ??                  <2>  .unitnm db ?
    96 00000002 ??                  <2>  .cmdcde db ?
    97 00000003 ????                <2>  .status dw ?
    98 00000005 ????????????????    <2>  .devptr dq ?
    99                              <2> 
   161                              <1>      
   162                              <1> endstruc
   163                              <1> 
   164                              <1> struc openReqPkt ;Open Device Request Packet
   165                              <1> 
   166                              <1>     drvReqHdrM    ;Common Driver Header Macro
    93                              <2> 
    94 00000000 ??                  <2>  .hdrlen db ?
    95 00000001 ??                  <2>  .unitnm db ?
    96 00000002 ??                  <2>  .cmdcde db ?
    97 00000003 ????                <2>  .status dw ?
    98 00000005 ????????????????    <2>  .devptr dq ?
    99                              <2> 
   167                              <1>      
   168                              <1> endstruc
   169                              <1> 
   170                              <1> struc closeReqPkt ;Close Device Request Packet
   171                              <1> 
   172                              <1>     drvReqHdrM    ;Common Driver Header Macro
    93                              <2> 
    94 00000000 ??                  <2>  .hdrlen db ?
    95 00000001 ??                  <2>  .unitnm db ?
    96 00000002 ??                  <2>  .cmdcde db ?
    97 00000003 ????                <2>  .status dw ?
    98 00000005 ????????????????    <2>  .devptr dq ?
    99                              <2> 
   173                              <1>      
   174                              <1> endstruc
   175                              <1> 
   176                              <1> struc remMediaReqPkt ;Removeable Media Request Packet
   177                              <1> 
   178                              <1>     drvReqHdrM    ;Common Driver Header Macro
    93                              <2> 
    94 00000000 ??                  <2>  .hdrlen db ?
    95 00000001 ??                  <2>  .unitnm db ?
    96 00000002 ??                  <2>  .cmdcde db ?
    97 00000003 ????                <2>  .status dw ?
    98 00000005 ????????????????    <2>  .devptr dq ?
    99                              <2> 
   179                              <1>      
   180                              <1> endstruc
   181                              <1> 
   182                              <1> struc ioctlReqPkt    ;Generic IOCTL Request Packet
   183                              <1> 
   184                              <1>     drvReqHdrM    ;Common Driver Header Macro  
    93                              <2> 
    94 00000000 ??                  <2>  .hdrlen db ?
    95 00000001 ??                  <2>  .unitnm db ?
    96 00000002 ??                  <2>  .cmdcde db ?
    97 00000003 ????                <2>  .status dw ?
    98 00000005 ????????????????    <2>  .devptr dq ?
    99                              <2> 
   185 0000000D ??                  <1>     .majfun db ?  ;Major function number
   186 0000000E ??                  <1>     .minfun db ?  ;Minor function number
   187 0000000F ????????????????    <1>     .rsival dq ?  ;Contents of RSI
   188 00000017 ????????????????    <1>     .rdival dq ?  ;Contents of RDI
   189 0000001F ????????????????    <1>     .ctlptr dq ?  ;Pointer to Generic IOCTL Request Packet
   190                              <1> 
   191                              <1> endstruc
   192                              <1> 
   193                              <1> struc getDevReqPkt ;Get Logical Device Request Packet
   194                              <1>     
   195                              <1>     drvReqHdrM    ;Common Driver Header Macro
    93                              <2> 
    94 00000000 ??                  <2>  .hdrlen db ?
    95 00000001 ??                  <2>  .unitnm db ?
    96 00000002 ??                  <2>  .cmdcde db ?
    97 00000003 ????                <2>  .status dw ?
    98 00000005 ????????????????    <2>  .devptr dq ?
    99                              <2> 
   196                              <1> 
   197                              <1> endstruc
   198                              <1> 
   199                              <1> struc setDevReqPkt ;Set Logical Device Request Packet
   200                              <1>     
   201                              <1>     drvReqHdrM    ;Common Driver Header Macro
    93                              <2> 
    94 00000000 ??                  <2>  .hdrlen db ?
    95 00000001 ??                  <2>  .unitnm db ?
    96 00000002 ??                  <2>  .cmdcde db ?
    97 00000003 ????                <2>  .status dw ?
    98 00000005 ????????????????    <2>  .devptr dq ?
    99                              <2> 
   202                              <1> 
   203                              <1> endstruc
   204                              <1> 
   205                              <1> 
   206                              <1> struc genioctlGetParamsTable
   207 00000000 ??                  <1>     .size           db ?
   208 00000001 ??????????????      <1>     .res            db 7 dup (?)
   209 00000008 ????????????????    <1>     .sectorSize     db 8 dup (?)  ;Only the lower dword is valid here
   210 00000010 ????????????????    <1>     .numSectors     db 8 dup (?)
   211                              <1> endstruc
   212                              <1> 
   213                              <1> ;THE WRITE STRUCT MUST BE A STRICT SUPERSET OF THE FORMAT STRUCT ALWAYS
   214                              <1> struc genioctlLBAformat
   215 00000000 ??                  <1>     .size           db ?
   216 00000001 ??                  <1>     .numSectors     db ?  ;Number of sectors to format
   217 00000002 ????????????        <1>     .res            db 6 dup (?)
   218 00000008 ????????????????    <1>     .startSector    db 8 dup (?)  ;Sector to start format at
   219                              <1> endstruc
   220                              <1> 
   221                              <1> struc genioctlLBAwrite
   222 00000000 ??                  <1>     .size           db ?
   223 00000001 ??                  <1>     .numSectors     db ?  ;Number of sectors to write
   224 00000002 ????????????        <1>     .res            db 6 dup (?)
   225 00000008 ????????????????    <1>     .startSector    db 8 dup (?)  ;Sector to start write at
   226 00000010 ????????????????    <1>     .xferBuffer     db 8 dup (?)  ;Transfer buffer for data
   227                              <1> endstruc
     6                                  %include "./src/inc/dosMacro.mac"
     1                              <1> 
     2                              <1> ;-------------------------------------------------------------------------------
     3                              <1> ;Generic Macros file
     4                              <1> ;The following instruction extensions allow to conditionally return
     5                              <1> ;The idea was borrowed from the DOS Source Code
     6                              <1> ;
     7                              <1> ;-------------------------------------------------------------------------------
     8                              <1> 
     9                              <1> ;-------------------------------------------------------------------------------
    10                              <1> ;These macros are live and must not be touched
    11                              <1> ;-------------------------------------------------------------------------------
    12                              <1> %macro return 0
    13                              <1>     ret
    14                              <1> %endmacro
    15                              <1> 
    16                              <1> %macro cret 1
    17                              <1>     j%-1 short %%a
    18                              <1>     return
    19                              <1> %%a:
    20                              <1> %endmacro
    21                              <1> 
    22                              <1> %macro retz 0
    23                              <1> cret z
    24                              <1> %endmacro
    25                              <1> 
    26                              <1> %macro retnz 0
    27                              <1> cret nz
    28                              <1> %endmacro
    29                              <1> 
    30                              <1> %macro rete 0
    31                              <1> cret e
    32                              <1> %endmacro
    33                              <1> 
    34                              <1> %macro retne 0
    35                              <1> cret ne
    36                              <1> %endmacro
    37                              <1> 
    38                              <1> %macro retc 0
    39                              <1> cret c
    40                              <1> %endmacro
    41                              <1> 
    42                              <1> %macro retnc 0
    43                              <1> cret nc
    44                              <1> %endmacro
    45                              <1> 
    46                              <1> %macro retb 0
    47                              <1> cret b
    48                              <1> %endmacro
    49                              <1> 
    50                              <1> %macro retnb 0
    51                              <1> cret nb
    52                              <1> %endmacro
    53                              <1> 
    54                              <1> %macro reta 0
    55                              <1> cret a
    56                              <1> %endmacro
    57                              <1> 
    58                              <1> %macro retna 0
    59                              <1> cret na
    60                              <1> %endmacro
    61                              <1> 
    62                              <1> %macro breakpoint 0
    63                              <1> xchg bx, bx
    64                              <1> %endmacro
     7                                  
     8                                  Segment cseg code private align=16
     9                                  %include "./src/text/init.asm"
     1                              <1>     EXTERN bseg_start
     2                              <1>     EXTERN bseg_len
     3                              <1>     GLOBAL ep
     4                              <1> 
     5                              <1> ;Init code for Session Manager.
     6                              <1> ep:  ;Entry Point for SM
     7 00000000 B800300000          <1>     mov eax, 3000h  ;Get version number
     8 00000005 CD21                <1>     int 21h
     9 00000007 3C01                <1>     cmp al, 1   ;If the major number is 1 or below
    10 00000009 7615                <1>     jbe proceedBss
    11 0000000B 488D15(32000000)    <1>     lea rdx, bvStr
    12                              <1> exitBad:
    13                              <1> ;Bad exits in init jump here
    14 00000012 B800090000          <1>     mov eax, 0900h
    15 00000017 CD21                <1>     int 21h
    16 00000019 B8FF4C0000          <1>     mov eax, 4CFFh
    17 0000001E CD21                <1>     int 21h
    18                              <1> proceedBss:
    19                              <1> ;Clean the BSS
    20 00000020 488D3D(00000000)    <1>     lea rdi, bseg_start
    21 00000027 B9[00000000]        <1>     mov ecx, bseg_len
    22 0000002C 31C0                <1>     xor eax, eax
    23 0000002E F3AA                <1>     rep stosb
    24                              <1> ;Save the PSP pointer for the Session (DOS) Manager
    25 00000030 4C8905(00000000)    <1>     mov qword [pDosMgrPsp], r8
    26                              <1> ;Check that STDIO is not redirected from the standard console device.
    27                              <1> ;This can be an AUX driver, the test for MCON compliance occurs below!
    28                              <1> ;If it is, exit complaining!
    29 00000037 31DB                <1>     xor ebx, ebx    ;STDIN
    30 00000039 B800440000          <1>     mov eax, 4400h  ;Get Hdl info
    31 0000003E CD21                <1>     int 21h
    32 00000040 89D3                <1>     mov ebx, edx    ;Save the returned word in bx
    33 00000042 488D15(6C010000)    <1>     lea rdx, noIOCTLStr
    34 00000049 72C7                <1>     jc exitBad
    35 0000004B 488D15(8E010000)    <1>     lea rdx, noStdinStr
    36 00000052 81E381000000        <1>     and ebx, 81h    ;Save bits 7 and 0 (Char dev and STDIN device)
    37 00000058 81FB81000000        <1>     cmp ebx, 81h
    38 0000005E 75B2                <1>     jne exitBad
    39                              <1> 
    40 00000060 BB01000000          <1>     mov ebx, 1      ;STDOUT
    41 00000065 B800440000          <1>     mov eax, 4400h  ;Get Hdl info
    42 0000006A CD21                <1>     int 21h
    43 0000006C 89D3                <1>     mov ebx, edx    ;Save the returned word in bx
    44 0000006E 488D15(6C010000)    <1>     lea rdx, noIOCTLStr
    45 00000075 729B                <1>     jc exitBad
    46 00000077 488D15(BD010000)    <1>     lea rdx, noStdoutStr
    47 0000007E 81E382000000        <1>     and ebx, 82h    ;Save bits 7 and 1 (Char dev and STDOUT device)
    48 00000084 81FB82000000        <1>     cmp ebx, 82h
    49 0000008A 7586                <1>     jne exitBad
    50                              <1> ;XCHG ptrs with MCON, driver specific IOCTL call
    51 0000008C 31F6                <1>     xor esi, esi
    52 0000008E 31FF                <1>     xor edi, edi
    53 00000090 56                  <1>     push rsi        ;Push two 0's onto the stack to allocate struc on stack
    54 00000091 56                  <1>     push rsi
    55 00000092 4889E2              <1>     mov rdx, rsp    ;Allocated structure on the stack
    56 00000095 66C7020001          <1>     mov word [rdx + mScrCap.wVer], 0100h
    57 0000009A 66C742020D00        <1>     mov word [rdx + mScrCap.wLen], mScrCap_size
    58 000000A0 488D1D07040000      <1>     lea rbx, devHlp
    59 000000A7 48895A05            <1>     mov qword [rdx + mScrCap.pDevHlp], rbx
    60 000000AB B80C440000          <1>     mov eax, 440Ch
    61 000000B0 31DB                <1>     xor ebx, ebx    ;CON handle (STDIN)!
    62 000000B2 B940030000          <1>     mov ecx, 0340h  ;CON + Reports capacities!
    63 000000B7 CD21                <1>     int 21h
    64 000000B9 730C                <1>     jnc mConOk
    65 000000BB 488D15(55000000)    <1>     lea rdx, noConStr
    66 000000C2 E94BFFFFFF          <1>     jmp exitBad
    67                              <1> mConOk:
    68 000000C7 0FB65A04            <1>     movzx ebx, byte [rdx + mScrCap.bScrNum]
    69 000000CB B808000000          <1>     mov eax, 8      ;Maximum supported, 8 screens
    70 000000D0 39C3                <1>     cmp ebx, eax
    71 000000D2 0F47D8              <1>     cmova ebx, eax  ;Maximum supported session number is 7
    72 000000D5 FFCB                <1>     dec ebx         ;Turn into an index
    73 000000D7 891D(28000000)      <1>     mov dword [dMaxSesIndx], ebx   ;Store the max session number index.
    74                              <1> ;Restore the stack now!
    75 000000DD 5E                  <1>     pop rsi  
    76 000000DE 5E                  <1>     pop rsi
    77 000000DF 85DB                <1>     test ebx, ebx   ;If only one session possible, fail to start!
    78 000000E1 750C                <1>     jnz screensOk    ;Else, we know we have enough screens to proceed usefully!
    79                              <1> ;If not enough screens, indicate we are aborting!
    80 000000E3 488D15(7A000000)    <1>     lea rdx, noScreenStr
    81 000000EA E923FFFFFF          <1>     jmp exitBad
    82                              <1> screensOk:
    83                              <1> ;Now we set the maximum number of tasks
    84 000000EF C705(24000000)2000- <1>     mov dword [dMaxTask], MAX_TASK
    84 000000F7 0000                <1>
    85                              <1> ;Get the size of the SDA to know how big a pcb actually is.
    86 000000F9 B8065D0000          <1>     mov eax, 5D06h
    87 000000FE CD21                <1>     int 21h
    88 00000100 488935(08000000)    <1>     mov qword [pDosSda], rsi
    89 00000107 890D(14000000)      <1>     mov dword [dSdaLen], ecx   
    90 0000010D 8915(10000000)      <1>     mov dword [dSdaLenMin], edx
    91 00000113 81C1FA000000        <1>     add ecx, pcb_size
    92                              <1> ;Round up the pcb size to a 16-byte boundary.
    93 00000119 81C10F000000        <1>     add ecx, 0Fh
    94 0000011F C1E904              <1>     shr ecx, 4
    95 00000122 C1E104              <1>     shl ecx, 4
    96 00000125 890D(20000000)      <1>     mov dword [dPcbLen], ecx   ;Save the max length of a pcb.
    97                              <1> ;Now lets allocate a soth for pcbs
    98 0000012B 89C8                <1>     mov eax, ecx    
    99 0000012D 8B1D(24000000)      <1>     mov ebx, dword [dMaxTask]   ;Get the maximum number of tasks
   100 00000133 F7E3                <1>     mul ebx     ;Multiply size of pcb with max number of tasks.
   101                              <1> 
   102 00000135 0510000000          <1>     add eax, soth_size  ;Add the SOTH header size too
   103 0000013A 050F000000          <1>     add eax, 0Fh    ;Round result up by a paragraph
   104 0000013F C1E804              <1>     shr eax, 4      ;Turn into number of paragraphs
   105 00000142 89C3                <1>     mov ebx, eax
   106 00000144 B800480000          <1>     mov eax, 4800h
   107 00000149 CD21                <1>     int 21h
   108 0000014B 7318                <1>     jnc spaceOk
   109 0000014D 488D15(9B000000)    <1>     lea rdx, noMemStr
   110                              <1> exitMcon:
   111 00000154 B80C440000          <1>     mov eax, 440Ch  ;Generic IOCTL
   112 00000159 B948030000          <1>     mov ecx, 0348h  ;Deinstall mtask capabilities from CON
   113 0000015E CD21                <1>     int 21h
   114 00000160 E9ADFEFFFF          <1>     jmp exitBad
   115                              <1> spaceOk:
   116 00000165 50                  <1>     push rax        ;Save the pointer to the allocated block!
   117 00000166 4889C7              <1>     mov rdi, rax    ;Clear the space we just allocated!
   118 00000169 C1E304              <1>     shl ebx, 4
   119 0000016C 89D9                <1>     mov ecx, ebx  ;Get the number of bytes we allocated
   120 0000016E 31C0                <1>     xor eax, eax
   121 00000170 F3AA                <1>     rep stosb
   122 00000172 5F                  <1>     pop rdi         ;Get back the allocated block pointer!
   123                              <1> ;Now setup the SOTH with the right flags!
   124 00000173 48C707FFFFFFFF      <1>     mov qword [rdi + soth.pNextSoth], -1    ;End of chain marker!
   125 0000017A 8B0D(24000000)      <1>     mov ecx, dword [dMaxTask]
   126 00000180 894F08              <1>     mov dword [rdi + soth.dNumEntry], ecx   ;This table saves all tasks.
   127 00000183 66C7470C0100        <1>     mov word [rdi + soth.wObjType], OBJ_PCB ;We use this for PCBs
   128 00000189 8B0D(20000000)      <1>     mov ecx, dword [dPcbLen]
   129 0000018F 66894F0E            <1>     mov word [rdi + soth.wObjectSz], cx     ;This is the object size
   130 00000193 48893D(61000000)    <1>     mov qword [pObjTblHdr], rdi ;Save the pointer to the first object table here
   131                              <1> ;Now set up the PCB Table information
   132 0000019A 48893D(18000000)    <1>     mov qword [pPcbTbl], rdi    ;Store ptr to the first pcb soth here
   133 000001A1 4881C710000000      <1>     add rdi, soth_size          ;Go to the first entry here
   134 000001A8 C607FF              <1>     mov byte [rdi + pcb.bPcbInUse], -1  ;Set to allocated
   135 000001AB 48893D(41000000)    <1>     mov qword [pCurPtda], rdi ;The session manager is the current task
   136 000001B2 C705(3D000000)0000- <1>     mov dword [hCurPtda], SM_SESSION
   136 000001BA 0000                <1>
   137                              <1> ;Now copy the SDA over and the DOS state as things stand. rsi -> DOS SDA
   138 000001BC 488DBFDA000000      <1>     lea rdi, qword [rdi + pcb.sPtda + ptda.sdaCopy]
   139 000001C3 8B0D(14000000)      <1>     mov ecx, dword [dSdaLen]
   140 000001C9 F3A4                <1>     rep movsb   ;Copy over the SDA as it stands now, in peacetime!
   141                              <1> 
   142                              <1> ;Now launch dMaxSesIndx copies of COMMAND.COM.
   143 000001CB B800190000          <1>     mov eax, 1900h  ;Get in AL the current drive (0=A, ...)
   144 000001D0 CD21                <1>     int 21h
   145 000001D2 0441                <1>     add al, "A"
   146 000001D4 8805(04000000)      <1>     mov byte [dfltShell], al    
   147 000001DA 8805(13000000)      <1>     mov byte [dfltShell2], al   ;Store on the backup shell too
   148 000001E0 31C9                <1>     xor ecx, ecx    ;Default search attributes
   149 000001E2 488D15(04000000)    <1>     lea rdx, dfltShell
   150 000001E9 B8004E0000          <1>     mov eax, 4E00h  ;Find First
   151 000001EE CD21                <1>     int 21h
   152 000001F0 731C                <1>     jnc .shellFnd
   153 000001F2 488D15(13000000)    <1>     lea rdx, dfltShell2
   154 000001F9 B8004E0000          <1>     mov eax, 4E00h  ;Find First
   155 000001FE CD21                <1>     int 21h
   156 00000200 730C                <1>     jnc .shellFnd
   157 00000202 488D15(D4000000)    <1>     lea rdx, noCmdStr
   158 00000209 E946FFFFFF          <1>     jmp exitMcon
   159                              <1> .shellFnd:
   160 0000020E 488915(2C000000)    <1>     mov qword [pCmdShell], rdx    ;Save the string to the program to spawn
   161                              <1> 
   162                              <1> ;Setup this Int 22h. If the COMMAND.COM of a session exits, then 
   163                              <1> ; this handler is executed. COMMAND.COM when loaded as /P will override 
   164                              <1> ; this in both the IDT and in its own PSP so this is very much for any
   165                              <1> ; early accidents. Eventually, will replace this with a routine that 
   166                              <1> ; tries to launch a new instance of the program specified in the sm.ini 
   167                              <1> ; config file.
   168 00000215 488D1583090000      <1>     lea rdx, i22hHdlr   ;Install the tmp Int 22h handler!
   169 0000021C B822250000          <1>     mov eax, 2522h
   170 00000221 CD21                <1>     int 21h
   171                              <1> 
   172 00000223 488D1590090000      <1>     lea rdx, interruptExit  
   173 0000022A B82E250000          <1>     mov eax, 252Eh  ;Eliminate any COMMAND.COM hook that might be present!
   174 0000022F CD21                <1>     int 21h
   175                              <1> 
   176                              <1> ;Now we spawn each task one by one.
   177                              <1> ;After each spawn, we copy the SDA into the pcb for that task.
   178                              <1> ;This way, each task has the right current psp, dta, drive and dos state.
   179                              <1> ;After each spawn, pull the rax value from the child stack, replacing
   180                              <1> ; it with the rip value to start program execution. 
   181                              <1> ;Place 0202h flags, PSPptr in r8 and r9 and rax in rax on the register stack.
   182                              <1> 
   183                              <1> ;Prepare the sda copy pointer
   184 00000231 B901000000          <1>     mov ecx, 1      ;Goto the first pcb 
   185 00000236 E878070000          <1>     call getPcbPtr  ;Get the ptr in rdi
   186                              <1> 
   187 0000023B 4881EC30000000      <1>     sub rsp, loadProg_size  ;Make space for the loadprog structure
   188 00000242 4889E5              <1>     mov rbp, rsp
   189 00000245 B901000000          <1>     mov ecx, 1  ;Start counting task numbers from 1
   190                              <1> ;Now setup the loadProgBlock on the stack
   191 0000024A 31C0                <1>     xor eax, eax
   192 0000024C 48894500            <1>     mov qword [rbp + loadProg.pEnv], rax    ;Copy the parent environment!
   193 00000250 488D05(26000000)    <1>     lea rax, cmdTail
   194 00000257 48894508            <1>     mov qword [rbp + loadProg.pCmdLine], rax
   195 0000025B 498D405C            <1>     lea rax, qword [r8 + psp.fcb1]
   196 0000025F 48894510            <1>     mov qword [rbp + loadProg.pfcb1], rax
   197 00000263 498D406C            <1>     lea rax, qword [r8 + psp.fcb2]
   198 00000267 48894518            <1>     mov qword [rbp + loadProg.pfcb2], rax
   199                              <1> loadLp:
   200 0000026B 31C0                <1>     xor eax, eax
   201 0000026D 48894520            <1>     mov qword [rbp + loadProg.initRSP], rax ;Reset the return values to 0
   202 00000271 48894528            <1>     mov qword [rbp + loadProg.initRIP], rax
   203 00000275 488B15(2C000000)    <1>     mov rdx, qword [pCmdShell]
   204 0000027C 4889EB              <1>     mov rbx, rbp
   205 0000027F B8014B0000          <1>     mov eax, 4B01h
   206 00000284 CD21                <1>     int 21h
   207 00000286 7316                <1>     jnc .loadOk
   208                              <1> .badLoad:
   209 00000288 488D15(08010000)    <1>     lea rdx, noExecStr
   210                              <1>     ;Here we have to unwind the programs, set Int 22h in each PSP 
   211                              <1>     ; to an appropriate loaction, copy the SDA into DOS, and call EXIT.
   212                              <1>     ;For now, we cause a memory leak and proceed.
   213 0000028F 4C89C3              <1>     mov rbx, r8     ;Move SM PSP pointer int rbx
   214 00000292 B800500000          <1>     mov eax, 5000h  ;Reset the current PSP back to SM
   215 00000297 CD21                <1>     int 21h
   216 00000299 E9B6FEFFFF          <1>     jmp exitMcon
   217                              <1> .loadOk:
   218                              <1> ;rdi points to the pcb for this task
   219 0000029E 488D05FA080000      <1>     lea rax, i22hHdlr
   220 000002A5 488987DA000000      <1>     mov qword [rdi + pcb.pInt22h], rax
   221 000002AC B823350000          <1>     mov eax, 3523h  ;Get the default Int 23h handler!
   222 000002B1 CD21                <1>     int 21h
   223 000002B3 48899FE2000000      <1>     mov qword [rdi + pcb.pInt23h], rbx
   224 000002BA B824350000          <1>     mov eax, 3524h  ;Get the default Int 24h handler!
   225 000002BF CD21                <1>     int 21h
   226 000002C1 48899FEA000000      <1>     mov qword [rdi + pcb.pInt24h], rbx
   227 000002C8 488D1DEB080000      <1>     lea rbx, interruptExit
   228 000002CF 48899FF2000000      <1>     mov qword [rdi + pcb.pInt2Eh], rbx
   229                              <1> ;   breakpoint
   230 000002D6 488B5D20            <1>     mov rbx, qword [rbp + loadProg.initRSP]
   231 000002DA 48895F52            <1>     mov qword [rdi + pcb.sPtda + ptda.qRSP], rbx ;Store the Stack value!
   232 000002DE 488B4528            <1>     mov rax, qword [rbp + loadProg.initRIP] 
   233 000002E2 488703              <1>     xchg rax, qword [rbx]   ;Swap the RIP value with the FCB words on the stack!
   234 000002E5 488987D2000000      <1>     mov qword [rdi + pcb.sPtda + ptda.sRegsTbl + 15*8], rax ;rax on regstack!
   235 000002EC B800510000          <1>     mov eax, 5100h  ;Get Current PSP in rbx
   236 000002F1 CD21                <1>     int 21h
   237 000002F3 48899F92000000      <1>     mov qword [rdi + pcb.sPtda + ptda.sRegsTbl + 7*8], rbx  ;PSP ptr @ r9
   238 000002FA 48899F9A000000      <1>     mov qword [rdi + pcb.sPtda + ptda.sRegsTbl + 8*8], rbx  ;PSP ptr @ r8
   239 00000301 48C7475A02020000    <1>     mov qword [rdi + pcb.sPtda + ptda.sRegsTbl], 0202h      ;Flags!
   240                              <1> ;Make sure to save the screen number and process information!
   241 00000309 894F0D              <1>     mov dword [rdi + pcb.hScrnNum], ecx     ;Save the screen number of task!
   242 0000030C 894F01              <1>     mov dword [rdi + pcb.hPcb], ecx ;This is also the count of the task!
   243 0000030F 894F05              <1>     mov dword [rdi + pcb.hParPcb], ecx 
   244 00000312 894F09              <1>     mov dword [rdi + pcb.dCsid], ecx 
   245 00000315 C607FF              <1>     mov byte [rdi + pcb.bPcbInUse], -1  ;Set to allocated
   246                              <1> 
   247                              <1> ;Now copy the SDA into the pcb SDA
   248 00000318 51                  <1>     push rcx
   249 00000319 488B35(08000000)    <1>     mov rsi, qword [pDosSda]
   250 00000320 488DBFDA000000      <1>     lea rdi, qword [rdi + pcb.sPtda + ptda.sdaCopy]
   251 00000327 8B0D(14000000)      <1>     mov ecx, dword [dSdaLen]
   252 0000032D F3A4                <1>     rep movsb   ;rdi now points to the next pcb
   253 0000032F 59                  <1>     pop rcx
   254                              <1> ;Now reset the PSP back so that each process is a proper child of SM!
   255 00000330 B800500000          <1>     mov eax, 5000h  ;Set current PSP
   256 00000335 4C89C3              <1>     mov rbx, r8
   257 00000338 CD21                <1>     int 21h
   258 0000033A FFC1                <1>     inc ecx
   259 0000033C 3B0D(28000000)      <1>     cmp ecx, dword [dMaxSesIndx]
   260 00000342 0F8623FFFFFF        <1>     jbe loadLp
   261                              <1> 
   262 00000348 4881C430000000      <1>     add rsp, loadProg_size  ;Reclaim the allocation in the end
   263                              <1> 
   264                              <1> ;Set ourselves to be our own parent now!
   265 0000034F 4D894022            <1>     mov qword [r8 + psp.parentPtr], r8
   266                              <1> ;Setup the default int 22h and int 23h of the SM in the PSP since we are our
   267                              <1> ; own Parent. No need to set the interrupt vectors, thats done on entry to the 
   268                              <1> ; shell.
   269 00000353 31C9                <1>     xor ecx, ecx    ;SM Hdl
   270 00000355 E859060000          <1>     call getPcbPtr  ;Get the ptr in rdi 
   271 0000035A 4889FE              <1>     mov rsi, rdi    ;Move ptr to rsi
   272                              <1> 
   273 0000035D 488D154B080000      <1>     lea rdx, i22hShell
   274 00000364 4989500A            <1>     mov qword [r8 + psp.oldInt22h], rdx
   275 00000368 488996DA000000      <1>     mov qword [rsi + pcb.pInt22h], rdx
   276 0000036F 488D153E080000      <1>     lea rdx, i23hHdlr
   277 00000376 49895012            <1>     mov qword [r8 + psp.oldInt23h], rdx
   278 0000037A 488996E2000000      <1>     mov qword [rsi + pcb.pInt23h], rdx
   279 00000381 488D1530080000      <1>     lea rdx, i24hHdlr
   280 00000388 4989501A            <1>     mov qword [r8 + psp.oldInt24h], rdx
   281 0000038C 488996EA000000      <1>     mov qword [rsi + pcb.pInt24h], rdx
   282                              <1> ;Now we gotta setup RIP, RSP, flags and regs for the Session Manager
   283 00000393 488D15(00000000)    <1>     lea rdx, sm$shlTOS
   284 0000039A 48895652            <1>     mov qword [rsi + pcb.sPtda + ptda.qRSP], rdx
   285 0000039E 488D156B060000      <1>     lea rdx, shellMain  ;We enter at shellMain (interrupts on, and rsp ok)
   286 000003A5 488996D2000000      <1>     mov qword [rsi + pcb.sPtda + ptda.sRegsTbl + 15*8], rdx ;Set RIP
   287 000003AC 4C898E92000000      <1>     mov qword [rsi + pcb.sPtda + ptda.sRegsTbl + 7*8], r9  ;PSP ptr @ r9
   288 000003B3 4C89869A000000      <1>     mov qword [rsi + pcb.sPtda + ptda.sRegsTbl + 8*8], r8  ;PSP ptr @ r8
   289 000003BA 48C7465A02020000    <1>     mov qword [rsi + pcb.sPtda + ptda.sRegsTbl], 0202h     ;flags
   290                              <1> 
   291                              <1> ;Now put every task into middle priority list (schedule 15)!
   292 000003C2 B00F                <1>     mov al, 15
   293 000003C4 E823060000          <1>     call getSchedHeadPtr    ;Get the schedhead ptr in rsi
   294                              <1> ;Now add all the tasks's we've just created to this list
   295 000003C9 31C9                <1>     xor ecx, ecx
   296 000003CB E8E3050000          <1>     call getPcbPtr     ;Get pcb pointer in rdi for task 0
   297 000003D0 E812060000          <1>     call getRootPtdaPtr  ;Get ptr to the first ptda of rdi in rbp
   298 000003D5 FF06                <1>     inc dword [rsi + schedHead.dNumEntry]
   299 000003D7 48896E04            <1>     mov qword [rsi + schedHead.pSchedHead], rbp ;This is the head
   300 000003DB 48896E0C            <1>     mov qword [rsi + schedHead.pSchedTail], rbp ;Tis also the tail!
   301                              <1> schedLp:
   302 000003DF FFC1                <1>     inc ecx
   303 000003E1 3B0D(28000000)      <1>     cmp ecx, dword [dMaxSesIndx]    ;We start by launching this amount of tasks.
   304 000003E7 771A                <1>     ja schedExit
   305 000003E9 E8C5050000          <1>     call getPcbPtr     ;Get pcb pointer in rdi for task ecx
   306 000003EE E8F4050000          <1>     call getRootPtdaPtr   ;Get ptr to the first ptda of rdi in rbp
   307 000003F3 488B7E0C            <1>     mov rdi, qword [rsi + schedHead.pSchedTail] ;Get the last entry in the sched
   308 000003F7 48896F1A            <1>     mov qword [rdi + ptda.pNSlepPtda], rbp    ;rbp comes after this 
   309 000003FB 48896E0C            <1>     mov qword [rsi + schedHead.pSchedTail], rbp ;This ptda is the new last ptda
   310 000003FF FF06                <1>     inc dword [rsi + schedHead.dNumEntry]       ;Added a new element to schedule
   311 00000401 EBDC                <1>     jmp short schedLp
   312                              <1> schedExit:
   313                              <1> 
   314 00000403 EB2C                <1>     jmp short i2ahJmp   ;Skip the timer stuff
   315                              <1> ;Now setup the timer infrastructure for the timer interrupt.
   316                              <1> ;Start by replacing the old timer interrupt with our better one.
   317 00000405 FA                  <1>     cli         ;Start by ensuring interrupts are off!
   318 00000406 B8F0350000          <1>     mov eax, 3500h | timerInt  ;Get ptr to timer interrupt in rbx
   319 0000040B CD21                <1>     int 21h
   320 0000040D 48891D(FE020000)    <1>     mov qword [pOldTimer], rbx
   321 00000414 488D1514010000      <1>     lea rdx, timerIrq ;Get the pointer to the new handler
   322 0000041B B8F0250000          <1>     mov eax, 2500h | timerInt  ;Set ptr for timer interrupt
   323 00000420 CD21                <1>     int 21h
   324                              <1> 
   325                              <1> ;Now we set the timer to trigger and interrupt every ms.
   326 00000422 B036                <1>     mov al, 36h     ;Channel 0, same settings as BIOS
   327 00000424 E643                <1>     out PITcmd, al
   328                              <1>  
   329 00000426 B8A9040000          <1>     mov eax, 1193   ;Divisor to get frequency of 1000.15Hz
   330 0000042B E640                <1>     out PIT0, al    ;Set low byte of PIT reload value
   331 0000042D 88E0                <1>     mov al, ah      ;ax = high 8 bits of reload value
   332 0000042F E640                <1>     out PIT0, al    
   333                              <1> i2ahJmp:
   334                              <1> ;Now setup the Int 2Ah infrastructure.
   335 00000431 488D1545010000      <1>     lea rdx, i2AhDisp
   336 00000438 B82A250000          <1>     mov eax, 252Ah
   337 0000043D CD21                <1>     int 21h
   338                              <1> ;Patch the DOS kernel to call Int 2Ah correctly.
   339                              <1> ;Go in reverse from rsi which points to the DOS SDA
   340 0000043F 488B35(08000000)    <1>     mov rsi, qword [pDosSda]
   341 00000446 488D5EFF            <1>     lea rbx, qword [rsi - 1]
   342 0000044A 488B7BF8            <1>     mov rdi, qword [rbx - 8]
   343 0000044E C60750              <1>     mov byte [rdi], 050h    ;Change from RET to PUSH RAX
   344 00000451 488B7BF0            <1>     mov rdi, qword [rbx - 16]
   345 00000455 C60750              <1>     mov byte [rdi], 050h    ;Change from RET to PUSH RAX
   346 00000458 488B7BE8            <1>     mov rdi, qword [rbx - 24]
   347 0000045C C60750              <1>     mov byte [rdi], 050h    ;Change from RET to PUSH RAX
   348 0000045F 488B7BE0            <1>     mov rdi, qword [rbx - 32]
   349 00000463 C60750              <1>     mov byte [rdi], 050h    ;Change from RET to PUSH RAX
   350                              <1> ;Now we are ready to jump!
   351                              <1> 
   352                              <1> ;
   353                              <1> ; TMP TMP TMP TMP TMP TMP TMP TMP
   354                              <1> ;
   355 00000466 488D1509000000      <1>     lea rdx, errorStr
   356 0000046D B800090000          <1>     mov eax, 0900h
   357 00000472 CD21                <1>     int 21h
   358                              <1> lp:
   359 00000474 EBFE                <1>     jmp short lp
   360 00000476 53657373696F6E204D- <1> errorStr db "Session Manager not ready yet. System halted!"
   360 0000047F 616E61676572206E6F- <1>
   360 00000488 742072656164792079- <1>
   360 00000491 65742E205379737465- <1>
   360 0000049A 6D2068616C74656421  <1>
   361                              <1> ;
   362                              <1> ; TMP TMP TMP TMP TMP TMP TMP TMP
   363                              <1> ;
   364                              <1> 
   365                              <1> ;Actual exit code below
   366 000004A3 FB                  <1>     sti         ;Ensure we return interrupts on!
   367 000004A4 B901000000          <1>     mov ecx, 1  ;Start COMMAND.COM on screen 1
   368 000004A9 E974060000          <1>     jmp swapScreen
    10                                  %include "./src/text/devhlp.asm"
     1                              <1> ;------------------------------------------------------------
     2                              <1> ;All the DOSMGR dispatcher functions live here.
     3                              <1> ;------------------------------------------------------------
     4                              <1> 
     5                              <1> 
     6                              <1> ;------------------------------------------------------------
     7                              <1> ;               DevHelp routines.
     8                              <1> ;------------------------------------------------------------
     9                              <1> ;Used by multitasking drivers to communicate events to DOS.
    10                              <1> devHlp:
    11                              <1> ;Dispatcher for devHlp.
    12                              <1> ;Function number passed in edx
    13 000004AE 81FA05000000        <1>     cmp edx, DevHlp_ConsInputFilter
    14 000004B4 7440                <1>     je consInputFilter  
    15 000004B6 81FA07000000        <1>     cmp edx, DevHlp_Signal_SM
    16 000004BC 7449                <1>     je signalSM      
    17 000004BE 81FA09000000        <1>     cmp edx, DevHlp_ProcBlock
    18 000004C4 0F84D4030000        <1>     je procBlock    
    19 000004CA 81FA0A000000        <1>     cmp edx, DevHlp_ProcRun
    20 000004D0 0F8407040000        <1>     je procRun      
    21 000004D6 81FA10000000        <1>     cmp edx, DevHlp_GetDOSVar
    22 000004DC 7402                <1>     je getDosVar    
    23 000004DE F9                  <1>     stc
    24                              <1>     return
    13 000004DF C3                  <2>  ret
    25                              <1> getDosVar:
    26                              <1> ;Currently only recognise one var, eax = 0, ebx = any, ecx = 1
    27                              <1> ;Returns the pointer to the var/array in rax
    28 000004E0 85C0                <1>     test eax, eax
    29 000004E2 7402                <1>     jz .getScrnIo
    30                              <1> .exitBad:
    31 000004E4 F9                  <1>     stc
    32                              <1>     return
    13 000004E5 C3                  <2>  ret
    33                              <1> .getScrnIo:
    34 000004E6 81F901000000        <1>     cmp ecx, 1  ;Is the var length one?
    35 000004EC 75F6                <1>     jne .exitBad
    36 000004EE 488D05(3A000000)    <1>     lea rax, bScrnIoOk  ;Else return the pointer (and CF=NC!)
    37                              <1>     return
    13 000004F5 C3                  <2>  ret
    38                              <1> consInputFilter:
    39                              <1> ;Checks if the char is to be added to the internal buffer or not!
    40                              <1> ;Currently only checks for the magic code for SM invokation.
    41                              <1> ;Input: ax=SC/ASCII char pair
    42                              <1> ;Output: ZF=NZ: char pair should be added to the internal buffer
    43                              <1> ;        ZF=ZE: char pair should NOT be added to the internal buffer
    44 000004F6 663D0071            <1>     cmp ax, magicCode   ;If the magic char, do not add to internal buffer
    45                              <1>     retne
    35                              <2> cret ne
    17 000004FA 7401                <3>  j%-1 short %%a
    18                              <3>  return
    13 000004FC C3                  <4>  ret
    19                              <3> %%a:
    46                              <1>     ;Here if the magic code was encounted.
    47 000004FD 50                  <1>     push rax
    48 000004FE 31C0                <1>     xor eax, eax    ;Magic code requests a swap to screen zero!
    49 00000500 E802000000          <1>     call signalSM
    50 00000505 58                  <1>     pop rax
    51                              <1>     return
    13 00000506 C3                  <2>  ret
    52                              <1> 
    53                              <1> signalSM:
    54                              <1> ;Entered with al = Suggested screen number. If bigger than maxsesindex, error!
    55 00000507 50                  <1>     push rax
    56 00000508 0FB6C0              <1>     movzx eax, al
    57 0000050B 3905(28000000)      <1>     cmp dword [dMaxSesIndx], eax
    58 00000511 58                  <1>     pop rax
    59                              <1>     retb    ;Exit with Carry Set!
    47                              <2> cret b
    17 00000512 7301                <3>  j%-1 short %%a
    18                              <3>  return
    13 00000514 C3                  <4>  ret
    19                              <3> %%a:
    60 00000515 9C                  <1>     pushfq
    61 00000516 FA                  <1>     cli 
    62 00000517 F605(3B000000)FF    <1>     test byte [bSM_Req], -1 ;If its set, dont set again!
    63 0000051E 750D                <1>     jnz .exit
    64 00000520 C605(3B000000)FF    <1>     mov byte [bSM_Req], -1  ;Set the bit
    65 00000527 8805(3C000000)      <1>     mov byte [bSM_Req_Scr], al   ;Suggest swapping to screen zero!
    66                              <1> .exit:
    67 0000052D 9D                  <1>     popfq
    68                              <1>     return
    13 0000052E C3                  <2>  ret
    11                                  %include "./src/text/int.asm"
     1                              <1> ;All DOSMGR interrupt routines go here (not SM Shell)
     2                              <1> 
     3                              <1> 
     4                              <1> timerIrq:
     5                              <1> ;This is the replacement interrupt handler. 
     6 0000052F FA                  <1>     cli
     7 00000530 E82D030000          <1>     call doSleepMgmt    ;Make sure to treat all sleeping tasks properly first!
     8 00000535 50                  <1>     push rax
     9 00000536 FE05(FB020000)      <1>     inc byte [bSliceCnt]     ;Increment the slice counter
    10 0000053C 0FB605(FC020000)    <1>     movzx eax, byte [bSliceSize]  ;Number of ms in one timeslice
    11 00000543 3805(FB020000)      <1>     cmp byte [bSliceCnt], al
    12 00000549 750E                <1>     jne .notaskSwitch
    13 0000054B 58                  <1>     pop rax
    14 0000054C E890020000          <1>     call taskSwitch  ;Change process
    15 00000551 50                  <1>     push rax
    16 00000552 C605(FB020000)00    <1>     mov byte [bSliceCnt], 0  ;Reset timer
    17                              <1> .notaskSwitch:
    18 00000559 FE05(FD020000)      <1>     inc byte [bTimerCnt] ;Increment the BIOS timer tracker
    19 0000055F 803D(FD020000)37    <1>     cmp byte [bTimerCnt], 55 ;Every 55ms trigger the old timer interrupt
    20 00000566 7407                <1>     je .callBIOSTimer ;Else, just exit normally
    21                              <1>     ;Else, tell the PIT to relax
    22 00000568 B020                <1>     mov al, EOI
    23 0000056A E620                <1>     out pic1cmd, al
    24 0000056C 58                  <1>     pop rax
    25                              <1> .exit:
    26 0000056D 48CF                <1>     iretq
    27                              <1> .callBIOSTimer:
    28 0000056F 58                  <1>     pop rax
    29 00000570 C605(FD020000)00    <1>     mov byte [bTimerCnt], 0  ;Reset the hw counter tracker
    30 00000577 FF25(FE020000)      <1>     jmp qword [pOldTimer]    ;Jump to the old timer
    31                              <1> 
    32                              <1> 
    33                              <1> ;------------------------------------------------------------
    34                              <1> ;Int 2Ah Dispatcher
    35                              <1> ;------------------------------------------------------------
    36                              <1> i2AhDisp:
    37                              <1> ;Enter with interrupts off! This is to prevent race conditions on waits!
    38 0000057D FA                  <1>     cli ;Disable interrupts
    39 0000057E 84E4                <1>     test ah, ah
    40 00000580 7427                <1>     jz status
    41 00000582 80FC03              <1>     cmp ah, 03h
    42 00000585 7426                <1>     je ioblock
    43 00000587 80FC80              <1>     cmp ah, 80h
    44 0000058A 7423                <1>     je enterCriticalSection
    45 0000058C 80FC81              <1>     cmp ah, 81h
    46 0000058F 0F84AA000000        <1>     je leaveCriticalSection
    47 00000595 80FC82              <1>     cmp ah, 82h
    48 00000598 0F84D8000000        <1>     je deleteCriticalSection
    49 0000059E 80FC84              <1>     cmp ah, 84h
    50 000005A1 0F840B010000        <1>     je releaseTimeslice
    51 000005A7 48CF                <1>     iretq
    52                              <1> 
    53                              <1> status:    ;AH=00h
    54 000005A9 B4FF                <1>     mov ah, -1
    55 000005AB 48CF                <1>     iretq
    56                              <1> 
    57                              <1> ioblock:    ;AH=03h
    58                              <1> ;Since singletasking DevDrvIO is properly protected through critical sections
    59                              <1> ; we only need to ensure that access to devices via BIOS calls, Int 25h 
    60                              <1> ; and Int 26h have not been interrupted. This can be done by hooking, placing a
    61                              <1> ; flag and incrementing the flag each time we enter and exit, then checking 
    62                              <1> ; if that flag is high for that device. 
    63                              <1> ;Input: rsi -> ASCIIZ string for device
    64 000005AD 48CF                <1>     iretq
    65                              <1> 
    66                              <1> enterCriticalSection:    ;AH=80h
    67                              <1> ;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    68                              <1> ; CAVEAT CAVEAT CAVEAT CAVEAT CAVEAT CAVEAT CAVEAT CAVEAT CAVEAT CAVEAT 
    69                              <1> ;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    70                              <1> ;In what follows, DOS and Driver critical section refers to 
    71                              <1> ; interruptable and uninterruptable critical section respectively.
    72                              <1> ;Uninterruptable critical sections behave specially in that they assume
    73                              <1> ; that they are always being called before a driver request UNLESS
    74                              <1> ; either RBX or RSI are null pointers, in which case the special driver
    75                              <1> ; handling is skipped.
    76                              <1> ;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    77                              <1> ;If this is called for a DOS critical section, attempts to give the 
    78                              <1> ; lock to the caller. If it cannot, the task is swapped until it gets its
    79                              <1> ; next quantum. If it can, the lock is allocated to it.
    80                              <1> ;
    81                              <1> ;SPECIAL CASE: If called for a Driver critical section, and the driver
    82                              <1> ; is normal DOS driver, then it acts as in the case of the DOS critical
    83                              <1> ; section. However, in the case of the driver having the undocumented
    84                              <1> ; multitasking bit set, then the driver will not give the lock to the 
    85                              <1> ; task as it is understood that the driver is capable of handling
    86                              <1> ; concurrent threads within it. Furthermore, if the driver is the 
    87                              <1> ; CON driver, and the request is a READ, WRITE or WRITE/VERIFY 
    88                              <1> ; then the session number (screen number) handle is placed in the 
    89                              <1> ; ioReqPkt.strtsc of the packet.
    90 000005AF 50                  <1>     push rax
    91 000005B0 57                  <1>     push rdi
    92 000005B1 84C0                <1>     test al, al
    93 000005B3 743E                <1>     jz .exit
    94 000005B5 663D0200            <1>     cmp ax, 2
    95 000005B9 7738                <1>     ja .exit
    96 000005BB 488D05(55000000)    <1>     lea rax, drvLock
    97 000005C2 488D3D(49000000)    <1>     lea rdi, dosLock
    98 000005C9 480F44F8            <1>     cmove rdi, rax  ;Move the drvlock into rdi if al = 2
    99 000005CD 7428                <1>     je .drvCrit     ;And go to the driver special handling code.
   100                              <1> ;Else, we are a DOS critical section, go straight to the lock code
   101                              <1> .lockMain:
   102                              <1> ;Entered with rdi -> Lock to check
   103 000005CF 488B05(41000000)    <1>     mov rax, qword [pCurPtda]   ;Get the ptr to the current task
   104 000005D6 813F00000000        <1>     cmp dword [rdi + critLock.dCount], 0    ;If the lock is free, take it!
   105 000005DC 7506                <1>     jne .noGive
   106 000005DE 48894704            <1>     mov qword [rdi + critLock.pOwnerPcb], rax  ;Set yourself as owner!
   107 000005E2 EB0D                <1>     jmp short .incCount
   108                              <1> .noGive:
   109 000005E4 48394704            <1>     cmp qword [rdi + critLock.pOwnerPcb], rax
   110 000005E8 7407                <1>     je .incCount    ;If we own the lock, increment the count!
   111 000005EA E8F2010000          <1>     call taskSwitch ;Else, put the calling task on ice for one cycle.
   112 000005EF EBDE                <1>     jmp short .lockMain     ;Try obtain the lock again!
   113                              <1> .incCount:
   114 000005F1 FF07                <1>     inc dword [rdi + critLock.dCount]   ;Increment the entry count!
   115                              <1> .exit:
   116 000005F3 5F                  <1>     pop rdi
   117 000005F4 58                  <1>     pop rax
   118 000005F5 48CF                <1>     iretq
   119                              <1> .drvCrit:
   120                              <1> ;Entered with:
   121                              <1> ;rdi -> Driver lock object
   122                              <1> ;rsi -> Driver header
   123                              <1> ;rbx -> Request packet
   124                              <1> ;If either rsi or rbx are NULL then we assume this is a non-driver 
   125                              <1> ; request for an uninterruptable critical section.
   126 000005F7 4885F6              <1>     test rsi, rsi
   127 000005FA 74D3                <1>     jz .lockMain
   128 000005FC 4885DB              <1>     test rbx, rbx
   129 000005FF 74CE                <1>     jz .lockMain
   130 00000601 0FB74608            <1>     movzx eax, word [rsi + drvHdr.attrib]
   131 00000605 66A92000            <1>     test ax, devDrvMulti
   132 00000609 74C4                <1>     jz .lockMain   ;If not a multitasking driver, try grab the lock!
   133                              <1> ;We reach the code below if we are entering an interruptable driver.
   134                              <1> ;In this case, we do not wait on the lock and proceed as normal.
   135 0000060B 66A90080            <1>     test ax , devDrvChar
   136 0000060F 74E2                <1>     jz .exit    ;Exit if not a char dev
   137 00000611 66250300            <1>     and ax, devDrvConIn | devDrvConOut
   138 00000615 74DC                <1>     jz .exit    ;If neither bit set, exit
   139                              <1> ;Here if this is either a MDOS CON In or CON Out device. 
   140                              <1> ;If request is read/write, place current task's screen number 
   141                              <1> ; in the ioReqPkt.strtsc field (we zxtend the byte to qword).
   142                              <1> ;This is a kludge as DOS is not multitasking so of course will not 
   143                              <1> ; do this for us :) It is the only reasonable way of communicating 
   144                              <1> ; the screen number of the task making the request to the driver.
   145 00000617 0FB64302            <1>     movzx eax, byte [rbx + drvReqHdr.cmdcde]
   146 0000061B 3D04000000          <1>     cmp eax, drvREAD
   147 00000620 740E                <1>     je .ioReq
   148 00000622 3D08000000          <1>     cmp eax, drvWRITE
   149 00000627 7407                <1>     je .ioReq
   150 00000629 3D09000000          <1>     cmp eax, drvWRITEVERIFY
   151 0000062E 75C3                <1>     jne .exit
   152                              <1> .ioReq:
   153 00000630 488B05(41000000)    <1>     mov rax, qword [pCurPtda]
   154 00000637 8B400D              <1>     mov eax, dword [rax + pcb.hScrnNum]
   155 0000063A 89431A              <1>     mov dword [rbx + ioReqPkt.strtsc], eax
   156 0000063D EBB4                <1>     jmp short .exit
   157                              <1> 
   158                              <1> leaveCriticalSection:    ;AH=81h
   159                              <1> ;If the calling task owns the lock, decrements the lock
   160 0000063F 50                  <1>     push rax
   161 00000640 57                  <1>     push rdi
   162 00000641 84C0                <1>     test al, al ;If 0, exit
   163 00000643 742D                <1>     jz .exit
   164 00000645 3C02                <1>     cmp al, 2
   165 00000647 7729                <1>     ja .exit    ;If above 2, exit
   166 00000649 488D3D(49000000)    <1>     lea rdi, dosLock
   167 00000650 488D05(55000000)    <1>     lea rax, drvLock
   168 00000657 480F44F8            <1>     cmove rdi, rax  ;Swap rdi to drvLock if AL=2
   169 0000065B 813F00000000        <1>     cmp dword [rdi + critLock.dCount], 0    ;If lock is free, exit!
   170 00000661 740F                <1>     je .exit
   171 00000663 488B05(41000000)    <1>     mov rax, qword [pCurPtda]   ;Else, check we own the lock
   172 0000066A 48394704            <1>     cmp qword [rdi + critLock.pOwnerPcb], rax
   173 0000066E 7502                <1>     jne .exit   ;If we don't own the lock, exit!
   174 00000670 FF0F                <1>     dec dword [rdi + critLock.dCount]   ;Else, decrement the lock!
   175                              <1> .exit:
   176 00000672 5F                  <1>     pop rdi
   177 00000673 58                  <1>     pop rax
   178 00000674 48CF                <1>     iretq
   179                              <1> 
   180                              <1> deleteCriticalSection:      ;AH=82h
   181                              <1> ;Will clear any critical sections OWNED by the task that is trying to 
   182                              <1> ; enter the lock! Else, this function will do nothing.
   183 00000676 50                  <1>     push rax
   184 00000677 57                  <1>     push rdi
   185 00000678 488B05(41000000)    <1>     mov rax, qword [pCurPtda]
   186 0000067F 488D3D(49000000)    <1>     lea rdi, dosLock
   187 00000686 E810000000          <1>     call .clearLock
   188 0000068B 488D3D(55000000)    <1>     lea rdi, drvLock
   189 00000692 E804000000          <1>     call .clearLock
   190 00000697 5F                  <1>     pop rdi
   191 00000698 58                  <1>     pop rax
   192 00000699 48CF                <1>     iretq
   193                              <1> .clearLock:
   194 0000069B F707FFFFFFFF        <1>     test dword [rdi + critLock.dCount], -1    ;Is this lock allocated?
   195                              <1>     retz    ;If this lock is free, exit! 
    23                              <2> cret z
    17 000006A1 7501                <3>  j%-1 short %%a
    18                              <3>  return
    13 000006A3 C3                  <4>  ret
    19                              <3> %%a:
   196 000006A4 48394704            <1>     cmp qword [rdi + critLock.pOwnerPcb], rax  ;Else, do we own it?
   197                              <1>     retne   ;If not, exit!
    35                              <2> cret ne
    17 000006A8 7401                <3>  j%-1 short %%a
    18                              <3>  return
    13 000006AA C3                  <4>  ret
    19                              <3> %%a:
   198 000006AB C70700000000        <1>     mov dword [rdi + critLock.dCount], 0    ;Else, free it!
   199                              <1>     return
    13 000006B1 C3                  <2>  ret
   200                              <1> 
   201                              <1> 
   202                              <1> releaseTimeslice:  ;AH=84h
   203                              <1> ;Intercepts the keyboard and releases the timeslice for the task that enters.
   204 000006B2 E82A010000          <1>     call taskSwitch
   205 000006B7 48CF                <1>     iretq
    12                                  %include "./src/text/swap.asm"
     1                              <1> ;All context switching functionality is here.
     2                              <1> 
     3                              <1> EXTERN sm$intTOS
     4                              <1> 
     5                              <1> 
     6                              <1> awakenNewTask:
     7                              <1> ;Sets the DOS and DOSMGR state for the new task to run.
     8                              <1> ;Input: ecx = Task number (handle) to switch to.
     9                              <1> ;Output: ecx set as current task.
    10                              <1> 
    11                              <1> 
    12                              <1> ;Set the SDA to the new tasks' SDA. 
    13 000006B9 488B1D(41000000)    <1>     mov rbx, qword [pCurPtda]
    14 000006C0 488DB3BA000000      <1>     lea rsi, qword [rbx + ptda.sdaCopy] ;Point rdi to the sda space
    15 000006C7 488B3D(08000000)    <1>     mov rdi, qword [pDosSda]
    16 000006CE 8B0D(14000000)      <1>     mov ecx, dword [dSdaLen]
    17 000006D4 F3A4                <1>     rep movsb   ;Transfer over the SDA
    18                              <1> 
    19                              <1> ;Set the new tasks' DOS interrupt handlers.
    20 000006D6 488B93F2000000      <1>     mov rdx, qword [rbx + pcb.pInt2Eh]
    21 000006DD B82E000000          <1>     mov eax, 2Eh
    22 000006E2 E8A4020000          <1>     call setIntVector    
    23 000006E7 488B93EA000000      <1>     mov rdx, qword [rbx + pcb.pInt24h]
    24 000006EE B824000000          <1>     mov eax, 24h
    25 000006F3 E893020000          <1>     call setIntVector
    26 000006F8 488B93E2000000      <1>     mov rdx, qword [rbx + pcb.pInt23h]
    27 000006FF B823000000          <1>     mov eax, 23h
    28 00000704 E882020000          <1>     call setIntVector
    29 00000709 488B93DA000000      <1>     mov rdx, qword [rbx + pcb.pInt22h]
    30 00000710 B822000000          <1>     mov eax, 22h
    31 00000715 E871020000          <1>     call setIntVector 
    32                              <1> 
    33                              <1> ;Now set the CON writing ok var if this task is on the same screen!
    34 0000071A C605(3A000000)00    <1>     mov byte [bScrnIoOk], 0 ;Denote output not ok
    35 00000721 488B3D(41000000)    <1>     mov rdi, qword [pCurPtda]    ;Get the thread ptr
    36 00000728 488B7F08            <1>     mov rdi, qword [rdi + ptda.pPcb]    ;Get ptr to the owner pcb.
    37 0000072C 8B470D              <1>     mov eax, dword [rdi + pcb.hScrnNum] ;Get the process screen number
    38 0000072F 3805(39000000)      <1>     cmp byte [bCurScrNum], al
    39                              <1>     retne
    35                              <2> cret ne
    17 00000735 7401                <3>  j%-1 short %%a
    18                              <3>  return
    13 00000737 C3                  <4>  ret
    19                              <3> %%a:
    40 00000738 FE0D(3A000000)      <1>     dec byte [bScrnIoOk]    ;Denote output ok!
    41                              <1>     return
    13 0000073E C3                  <2>  ret
    42                              <1> 
    43                              <1> sleepCurrentTask:
    44                              <1> ;Puts the current task on ice, saves all of its relevant state in 
    45                              <1> ; the pcb and then returns to the caller.
    46 0000073F 488B3D(41000000)    <1>     mov rdi, qword [pCurPtda]
    47 00000746 57                  <1>     push rdi    ;Save the CurTask pointer for use later!
    48 00000747 488DBFBA000000      <1>     lea rdi, qword [rdi + ptda.sdaCopy] ;Point rdi to the sda space
    49 0000074E 488B35(08000000)    <1>     mov rsi, qword [pDosSda]
    50 00000755 8B0D(14000000)      <1>     mov ecx, dword [dSdaLen]
    51 0000075B F3A4                <1>     rep movsb   ;Transfer over the SDA
    52 0000075D 5F                  <1>     pop rdi
    53                              <1> ;Save the current Int 22h, 23h and 24h handlers in the paused tasks' PCB.
    54 0000075E B822000000          <1>     mov eax, 22h
    55 00000763 E8F9010000          <1>     call getIntVector
    56 00000768 48899FDA000000      <1>     mov qword [rdi + pcb.pInt22h], rbx
    57 0000076F B823000000          <1>     mov eax, 23h
    58 00000774 E8E8010000          <1>     call getIntVector
    59 00000779 48899FE2000000      <1>     mov qword [rdi + pcb.pInt23h], rbx
    60 00000780 B824000000          <1>     mov eax, 24h
    61 00000785 E8D7010000          <1>     call getIntVector
    62 0000078A 48899FEA000000      <1>     mov qword [rdi + pcb.pInt24h], rbx
    63 00000791 B82E000000          <1>     mov eax, 2Eh
    64 00000796 E8C6010000          <1>     call getIntVector
    65 0000079B 48899FF2000000      <1>     mov qword [rdi + pcb.pInt2Eh], rbx
    66                              <1>     return
    13 000007A2 C3                  <2>  ret
    67                              <1> 
    68                              <1> chooseNextTask:
    69                              <1> ;Makes a choice of the next task. For now, its the next task,
    70                              <1> ; unless the SM has been signalled through the keyboard. Furthermore, 
    71                              <1> ; no task switch is enacted if we are in a critical section!
    72                              <1> 
    73                              <1> ;NOTE!! A task that owns a driver critical section (02h) MUST NOT be 
    74                              <1> ; interrupted. This is because the driver expects to have full control
    75                              <1> ; over the hardware and will not be happy if someone else tries to 
    76                              <1> ; do something whilst waiting for a new timeslice. A driver 
    77                              <1> ; can communicate that it is interruptable by setting the new multitasking
    78                              <1> ; bit in the header. Then Int 2Ah will no allocate the lock to it.
    79                              <1> ;A task that owns a DOS critical section (01h) can be interrupted.
    80                              <1> 
    81                              <1> ;Start by checking that we don't own the uninterruptable lock. If
    82                              <1> ; we do, exit! We should never be in a situation where it is allocated 
    83                              <1> ; and we don't own it here.
    84 000007A3 488B3D(41000000)    <1>     mov rdi, qword [pCurPtda]
    85 000007AA 8B05(55000000)      <1>     mov eax, dword [drvLock + critLock.dCount]
    86 000007B0 85C0                <1>     test eax, eax
    87 000007B2 7416                <1>     jz .noDrvLock   ;Not owned, proceed!
    88 000007B4 483B3D(59000000)    <1>     cmp rdi, qword [drvLock + critLock.pOwnerPcb]
    89                              <1>     rete    ;Return if they are equal!
    31                              <2> cret e
    17 000007BB 7501                <3>  j%-1 short %%a
    18                              <3>  return
    13 000007BD C3                  <4>  ret
    19                              <3> %%a:
    90 000007BE 488D15(10020000)    <1>     lea rdx, badLockStr
    91 000007C5 E96D010000          <1>     jmp fatalHalt
    92                              <1> .noDrvLock:
    93                              <1>     return   ;TMPTMP: Keep current task!
    13 000007CA C3                  <2>  ret
    94                              <1> ;Now we know we don't own the uninterruptable lock, we choose a task
    95                              <1> ; to swap to. rdi points to the current task.
    96                              <1>     
    97                              <1> ;1) Put this task on the back of its list.
    98                              <1> ;2) Go through each list until we get to the first not-null task.
    99                              <1> ;   If it is the same, find the next non-null task after it. 
   100                              <1> ;   This is to prevent this task from getting all the timeslices.
   101                              <1> 
   102                              <1> 
   103                              <1> ;End by setting the new task and signalling procrun on this
   104 000007CB 890D(3D000000)      <1>     mov dword [hCurPtda], ecx  ;Store the task number 
   105 000007D1 E8DD010000          <1>     call getPcbPtr ;Get ptr in rdi to the current PCB table
   106 000007D6 4889FB              <1>     mov rbx, rdi
   107 000007D9 48891D(41000000)    <1>     mov qword [pCurPtda], rbx           ;Setup internal data properly!
   108                              <1>     return
    13 000007E0 C3                  <2>  ret
   109                              <1> 
   110                              <1> 
   111                              <1> taskSwitch:
   112                              <1> ;Called always with interrupts turned off!
   113                              <1> ;If a task needed to be put to sleep for a period of time, then 
   114                              <1> ; we have already set the sleep information in the pcb before coming
   115                              <1> ; here.
   116 000007E1 48871D(41000000)    <1>     xchg qword [pCurPtda], rbx  ;Get the ptr to the current session. Save rbx.
   117 000007E8 48896352            <1>     mov qword [rbx + pcb.sPtda + ptda.qRSP], rsp
   118 000007EC 488DA3DA000000      <1>     lea rsp, qword [rbx + pcb.sPtda + ptda.boS] ;Point rsp to where to store regs
   119 000007F3 48871D(41000000)    <1>     xchg qword [pCurPtda], rbx  ;Get back the value of rbx in rbx.
   120 000007FA 50                  <1>     push rax
   121 000007FB 53                  <1>     push rbx
   122 000007FC 51                  <1>     push rcx
   123 000007FD 52                  <1>     push rdx
   124 000007FE 56                  <1>     push rsi
   125 000007FF 57                  <1>     push rdi
   126 00000800 55                  <1>     push rbp
   127 00000801 4150                <1>     push r8
   128 00000803 4151                <1>     push r9
   129 00000805 4152                <1>     push r10
   130 00000807 4153                <1>     push r11
   131 00000809 4154                <1>     push r12 
   132 0000080B 4155                <1>     push r13
   133 0000080D 4156                <1>     push r14
   134 0000080F 4157                <1>     push r15
   135 00000811 9C                  <1>     pushfq
   136 00000812 FC                  <1>     cld ;Ensure all writes occur in the right way.
   137 00000813 488D25(00000000)    <1>     lea rsp, sm$intTOS  ;Now go to the interrupt stack
   138                              <1> 
   139 0000081A E820FFFFFF          <1>     call sleepCurrentTask
   140 0000081F E87FFFFFFF          <1>     call chooseNextTask     ;Sets the task variables for the new task
   141 00000824 E890FEFFFF          <1>     call awakenNewTask
   142                              <1> 
   143 00000829 488B1D(41000000)    <1>     mov rbx, qword [pCurPtda]
   144                              <1> ;Skip reloading the flags here!
   145 00000830 488D6362            <1>     lea rsp, qword [rbx + pcb.sPtda + ptda.sRegsTbl + 8]
   146 00000834 415F                <1>     pop r15
   147 00000836 415E                <1>     pop r14
   148 00000838 415D                <1>     pop r13
   149 0000083A 415C                <1>     pop r12
   150 0000083C 415B                <1>     pop r11
   151 0000083E 415A                <1>     pop r10
   152 00000840 4159                <1>     pop r9
   153 00000842 4158                <1>     pop r8
   154 00000844 5D                  <1>     pop rbp
   155 00000845 5F                  <1>     pop rdi
   156 00000846 5E                  <1>     pop rsi
   157 00000847 5A                  <1>     pop rdx
   158 00000848 59                  <1>     pop rcx
   159 00000849 5B                  <1>     pop rbx
   160 0000084A 58                  <1>     pop rax
   161 0000084B 48871D(41000000)    <1>     xchg qword [pCurPtda], rbx
   162 00000852 488B6352            <1>     mov rsp, qword [rbx + pcb.sPtda + ptda.qRSP]
   163                              <1> ;Reload the flags once we have switched stacks!
   164 00000856 FF735A              <1>     push qword [rbx + pcb.sPtda + ptda.sRegsTbl]
   165 00000859 48871D(41000000)    <1>     xchg qword [pCurPtda], rbx  ;Now swap things back  
   166 00000860 9D                  <1>     popfq   ;Pop flags back right at the end :)
   167                              <1>     return
    13 00000861 C3                  <2>  ret
   168                              <1> 
   169                              <1> initScreen:
   170                              <1> ;This routine initialises/resets a screen
   171                              <1> 
   172                              <1> 
   173                              <1> screenSwitch:
   174                              <1> ;This routine enacts the screen switch. This will be exposed to standalone SM 
   175                              <1> ; via an undocumented Int 2Fh call and then via DLL... hopefully.
   176                              <1> ;Input: al = Screen number
   177                              <1> ;Output: Screen changed to al or if al is too large, return error (CF=CY)
   178                              <1> 
    13                                  %include "./src/text/proc.asm"
     1                              <1> ;Process and thread management routines live here
     2                              <1> 
     3                              <1> doSleepMgmt:
     4                              <1> ;Decrements the sleep counter for each sleeping ptda on the sleep list
     5                              <1> ; and removes entries from the list if they have finished their sleep.
     6 00000862 57                  <1>     push rdi
     7 00000863 56                  <1>     push rsi
     8 00000864 31F6                <1>     xor esi, esi    ;Zero the "previous" pointer
     9 00000866 488B3D(69000000)    <1>     mov rdi, qword [pHdSlpList]
    10                              <1> .lp:
    11 0000086D 4885FF              <1>     test rdi, rdi
    12 00000870 7429                <1>     jz .exit
    13 00000872 817F2200000000      <1>     cmp dword [rdi + ptda.dSleepLen], 0      ;A never awaken task?
    14 00000879 7417                <1>     je .gotoNext
    15 0000087B FF4F22              <1>     dec dword [rdi + ptda.dSleepLen]
    16 0000087E 7512                <1>     jnz .gotoNext
    17                              <1> ;Start by awakening the task.
    18 00000880 C6471801            <1>     mov byte [rdi + ptda.bState], THREAD_READY
    19                              <1> ;Now set that this task is being awoken due to timeout wakeup
    20 00000884 C7472601000000      <1>     mov dword [rdi + ptda.dAwakeCode], AWAKE_TIMEOUT
    21 0000088B E88A000000          <1>     call remFromSleepList   ;Remove ptda in rdi from sleep list
    22 00000890 EBDB                <1>     jmp short .lp
    23                              <1> .gotoNext:
    24 00000892 4889FE              <1>     mov rsi, rdi    ;Make the current ptda the anchor
    25 00000895 488B7F1A            <1>     mov rdi, qword [rdi + ptda.pNSlepPtda]    ;Get the next ptda
    26 00000899 EBD2                <1>     jmp short .lp
    27                              <1> .exit:
    28 0000089B 5E                  <1>     pop rsi
    29 0000089C 5F                  <1>     pop rdi
    30                              <1>     return
    13 0000089D C3                  <2>  ret
    31                              <1> 
    32                              <1> procBlock:
    33                              <1> ;Tells DOS to put this thread of execution for this task to sleep!
    34                              <1> ;Called with interrupts turned off.
    35                              <1> ;When called, use the following sequence:
    36                              <1> ; CLI
    37                              <1> ; while (condition)
    38                              <1> ;   prockBlock(eventId)
    39                              <1> ;Interrupts are turned off to prevent a race condition with procRun.
    40                              <1> ;
    41                              <1> ;Can only be called from a multitasking driver that declares itself so as
    42                              <1> ; these tasks don't enter the driver critical section.
    43                              <1> 
    44                              <1> ;Talks about the current procedure only!
    45                              <1> ;On entry: Interrupts are off. rbx = Event identifier. ecx = Timeout interval.
    46                              <1> ;           If dh != 0, the sleep can be awakened prematurely.
    47                              <1> ;On exit: Interrupts are on.
    48                              <1> ;   eax = Awake code.
    49                              <1> ;   CF=NC -> Event wakeup (i.e. procrun called on event id)
    50                              <1> ;   CF=CY -> Unusual wakeup,
    51                              <1> ;       ZF=ZE -> Timeout wakeup
    52                              <1> ;       ZF=NZ -> Someone (probably scheduler) woke up this task prematurely
    53 0000089E 56                  <1>     push rsi
    54 0000089F 57                  <1>     push rdi
    55 000008A0 488B3D(41000000)    <1>     mov rdi, qword [pCurPtda]
    56                              <1> ;Start by indicating that the thread can go to sleep.
    57 000008A7 C6471805            <1>     mov byte [rdi + ptda.bState], THREAD_WAITING
    58 000008AB 887719              <1>     mov byte [rdi + ptda.bSleepStat], dh    ;If <> 0, can be interrupted!
    59                              <1> ;Now set the event id and the length for the sleep 
    60 000008AE 48895F2A            <1>     mov qword [rdi + ptda.qEventId], rbx
    61 000008B2 894F22              <1>     mov dword [rdi + ptda.dSleepLen], ecx
    62 000008B5 488B35(69000000)    <1>     mov rsi, qword [pHdSlpList]   ;Get the old head of the list
    63 000008BC 48893D(69000000)    <1>     mov qword [pHdSlpList], rdi   ;Place us at the head of the list
    64 000008C3 4889771A            <1>     mov qword [rdi + ptda.pNSlepPtda], rsi    ;Make the old head the next second
    65 000008C7 E815FFFFFF          <1>     call taskSwitch             ;And now we swap tasks!
    66 000008CC 8B4726              <1>     mov eax, dword [rdi + ptda.dAwakeCode] 
    67 000008CF 85C0                <1>     test eax, eax
    68 000008D1 7406                <1>     jz .exit
    69 000008D3 3D01000000          <1>     cmp eax, AWAKE_TIMEOUT  ;Set zero flag if we were awoken due to timeout
    70 000008D8 F9                  <1>     stc
    71                              <1> .exit:
    72 000008D9 FB                  <1>     sti
    73 000008DA 5F                  <1>     pop rdi
    74 000008DB 5E                  <1>     pop rsi
    75                              <1>     return
    13 000008DC C3                  <2>  ret
    76                              <1> 
    77                              <1> procRun:
    78                              <1> ;We go through each queue and find every single thread block.
    79                              <1> ;On entry:  rbx = Event id to awaken tasks on.
    80                              <1> ;On exit:   eax = Count of processes woken up. If zero, ZF=ZE.
    81 000008DD 56                  <1>     push rsi
    82 000008DE 57                  <1>     push rdi
    83 000008DF 9C                  <1>     pushfq
    84 000008E0 FA                  <1>     cli     ;No int when doing this (figure something better)
    85 000008E1 31C0                <1>     xor eax, eax    ;Zero our counter of awoken tasks
    86 000008E3 31F6                <1>     xor esi, esi    ;Zero the "previous" pointer
    87 000008E5 488B3D(69000000)    <1>     mov rdi, qword [pHdSlpList]
    88                              <1> .lp:
    89 000008EC 4885FF              <1>     test rdi, rdi
    90 000008EF 7423                <1>     jz .exit
    91 000008F1 48395F2A            <1>     cmp qword [rdi + ptda.qEventId], rbx
    92 000008F5 7514                <1>     jne .gotoNext
    93                              <1> ;Awaken this task normally.
    94 000008F7 C6451801            <1>     mov byte [rbp + ptda.bState], THREAD_READY
    95 000008FB C7452600000000      <1>     mov dword [rbp + ptda.dAwakeCode], AWAKE_NORMAL
    96 00000902 FFC0                <1>     inc eax     ;Increment the counter
    97 00000904 E811000000          <1>     call remFromSleepList   ;Remove ptda in rdi from sleep list
    98 00000909 EBE1                <1>     jmp short .lp
    99                              <1> .gotoNext:
   100 0000090B 4889FE              <1>     mov rsi, rdi    ;Now make current ptda the prevptr
   101 0000090E 488B7F1A            <1>     mov rdi, qword [rdi + ptda.pNSlepPtda]    ;Get the next ptda
   102 00000912 EBD8                <1>     jmp short .lp
   103                              <1> .exit:
   104 00000914 9D                  <1>     popfq
   105 00000915 5F                  <1>     pop rdi
   106 00000916 5E                  <1>     pop rsi
   107 00000917 85C0                <1>     test eax, eax   ;Set ZF if appropriate
   108                              <1>     return
    13 00000919 C3                  <2>  ret
   109                              <1> 
   110                              <1> remFromSleepList:
   111                              <1> ;Removes the ptda in rdi out of the sleep list!
   112                              <1> ;Input: rdi -> ptda to be removed from sleeplist
   113                              <1> ;       rsi -> 0 if head of the sleeplist or previous ptda in list
   114                              <1> ;Now take the ptda out of the sleep list.
   115 0000091A 52                  <1>     push rdx
   116 0000091B 31D2                <1>     xor edx, edx    ;Set rdx to the nullptr
   117 0000091D 4887571A            <1>     xchg rdx, qword [rdi + ptda.pNSlepPtda] ;and swap nullptr with nextptr
   118 00000921 4889D7              <1>     mov rdi, rdx    ;Get the nextptr in rdi
   119 00000924 5A                  <1>     pop rdx
   120 00000925 4885F6              <1>     test rsi, rsi   ;Are we replacing the first ptda in the list?
   121 00000928 7508                <1>     jnz .noHead
   122 0000092A 48893D(69000000)    <1>     mov qword [pHdSlpList], rdi ;If so, put the link into the head
   123                              <1>     return
    13 00000931 C3                  <2>  ret
   124                              <1> .noHead:
   125                              <1> ;Else store nextptr in prevptda nexptr
   126 00000932 48897E1A            <1>     mov qword [rsi + ptda.pNSlepPtda], rdi
   127                              <1>     return
    13 00000936 C3                  <2>  ret
   128                              <1> 
   129                              <1> fatalHalt:
   130                              <1> ;This is the handler if a fatal error occurs where we need to halt the 
   131                              <1> ; machine. We call DOS as we don't need to preserve anything since we 
   132                              <1> ; freeze the machine. 
   133                              <1> ;Input: rdx -> String to print.
   134 00000937 52                  <1>     push rdx
   135 00000938 488D15(00020000)    <1>     lea rdx, fatalStr
   136 0000093F E815000000          <1>     call .outStr
   137 00000944 5A                  <1>     pop rdx
   138 00000945 E80F000000          <1>     call .outStr
   139 0000094A 488D15(3A020000)    <1>     lea rdx, sysHltStr
   140 00000951 E803000000          <1>     call .outStr
   141                              <1> ;
   142                              <1> ;Here provide a regdump of the system registers (and possibly stack?). 
   143                              <1> ;
   144 00000956 FA                  <1>     cli
   145                              <1> .deadLp:
   146 00000957 EBFE                <1>     jmp short .deadLp
   147                              <1> .outStr:
   148 00000959 B800090000          <1>     mov eax, 0900h
   149 0000095E CD21                <1>     int 21h
   150                              <1>     return
    13 00000960 C3                  <2>  ret
    14                                  %include "./src/text/util.asm"
     1                              <1> ;Misc utility functions go here
     2                              <1> 
     3                              <1> getIntVector:
     4                              <1> ;Called with:
     5                              <1> ;Interrupts Off!
     6                              <1> ; al = Interrupt number
     7                              <1> ;Returns: 
     8                              <1> ; rbx -> Ptr to interrupt handler
     9 00000961 0F010D(F1020000)    <1>     sidt [pIDT]    ;Get the current IDT base pointer
    10 00000968 0FB6C0              <1>     movzx eax, al
    11 0000096B 48C1E004            <1>     shl rax, 4h     ;Multiply IDT entry number by 16 (Size of IDT entry)
    12 0000096F 480305(F3020000)    <1>     add rax, qword [pIDT.base]    
    13 00000976 31DB                <1>     xor ebx, ebx
    14 00000978 8B5808              <1>     mov ebx, dword [rax + 8]    ;Get bits 63...32
    15 0000097B 48C1E310            <1>     shl rbx, 10h    ;Push the high dword high
    16 0000097F 668B5806            <1>     mov bx, word [rax + 6]      ;Get bits 31...16
    17 00000983 48C1E310            <1>     shl rbx, 10h    ;Push word 2 into posiiton
    18 00000987 668B18              <1>     mov bx, word [rax]          ;Get bits 15...0
    19                              <1>     return
    13 0000098A C3                  <2>  ret
    20                              <1> 
    21                              <1> setIntVector:
    22                              <1> ;Called with:
    23                              <1> ;Interrupts Off!
    24                              <1> ;   rdx = Pointer to interrupt handler
    25                              <1> ;   al = Interrupt number
    26 0000098B 0F010D(F1020000)    <1>     sidt [pIDT]    ;Get the current IDT base pointer
    27 00000992 0FB6C0              <1>     movzx eax, al
    28 00000995 48C1E004            <1>     shl rax, 4h     ;Multiply IDT entry number by 16 (Size of IDT entry)
    29 00000999 480305(F3020000)    <1>     add rax, qword [pIDT.base]    
    30 000009A0 668910              <1>     mov word [rax], dx  ;Get low word into offset 15...0
    31 000009A3 48C1EA10            <1>     shr rdx, 10h    ;Bring next word low
    32 000009A7 66895006            <1>     mov word [rax + 6], dx  ;Get low word into offset 31...16
    33 000009AB 48C1EA10            <1>     shr rdx, 10h    ;Bring last dword low
    34 000009AF 895008              <1>     mov dword [rax + 8], edx
    35                              <1>     return
    13 000009B2 C3                  <2>  ret
    36                              <1> 
    37                              <1> 
    38                              <1> getPcbPtr:
    39                              <1> ;Return a ptr to the requested PCB in rdi
    40                              <1> ;Input: ecx = Number of the pcb to get the pointer of!
    41                              <1> ;Output: rdi -> PCB requested
    42 000009B3 488B3D(18000000)    <1>     mov rdi, qword [pPcbTbl] ;Get head of SFT pointer
    43                              <1> .walk:
    44 000009BA 3B4F08              <1>     cmp ecx, dword [rdi + soth.dNumEntry]
    45 000009BD 7211                <1>     jb .thisTable
    46 000009BF 2B4F08              <1>     sub ecx, dword [rdi + soth.dNumEntry] ;Subtract
    47 000009C2 488B3F              <1>     mov rdi, qword [rdi + soth.pNextSoth] ;Goto next table
    48 000009C5 4881FFFFFFFFFF      <1>     cmp rdi, -1
    49 000009CC 75EC                <1>     jne .walk
    50 000009CE F9                  <1>     stc
    51                              <1>     return
    13 000009CF C3                  <2>  ret
    52                              <1> .thisTable:
    53 000009D0 50                  <1>     push rax
    54 000009D1 52                  <1>     push rdx
    55 000009D2 8B05(20000000)      <1>     mov eax, dword [dPcbLen]
    56 000009D8 F7E1                <1>     mul ecx
    57 000009DA 4801C7              <1>     add rdi, rax    ;Shift rdi to go to SFT entry in current table
    58 000009DD 5A                  <1>     pop rdx
    59 000009DE 58                  <1>     pop rax
    60 000009DF 4881C710000000      <1>     add rdi, soth_size  ;Go past the header
    61                              <1>     return
    13 000009E6 C3                  <2>  ret
    62                              <1> 
    63                              <1> getRootPtdaPtr:
    64                              <1> ;Input: rdi -> PCB to get the thread pointer to
    65                              <1> ;Output: rbp -> Ptda 0 of the process
    66 000009E7 488D6F20            <1>     lea rbp, qword [rdi + pcb.sPtda]
    67                              <1>     return
    13 000009EB C3                  <2>  ret
    68                              <1> 
    69                              <1> getSchedHeadPtr:
    70                              <1> ;Gets a pointer to your desired schedule.
    71                              <1> ;Input: al = Number of the schedule you desire (0-31)
    72 000009EC 50                  <1>     push rax
    73 000009ED 53                  <1>     push rbx
    74 000009EE BB1F000000          <1>     mov ebx, MAX_SCHED
    75 000009F3 29C3                <1>     sub ebx, eax    ;Get the reverse order schedule number in ebx
    76 000009F5 B814000000          <1>     mov eax, schedHead_size
    77 000009FA F7E3                <1>     mul ebx 
    78 000009FC 488D35(71000000)    <1>     lea rsi, schedBlk
    79 00000A03 4801C6              <1>     add rsi, rax
    80 00000A06 5B                  <1>     pop rbx
    81 00000A07 58                  <1>     pop rax
    82                              <1>     return 
    13 00000A08 C3                  <2>  ret
    15                                  %include "./src/text/shell.asm"
     1                              <1> ;This is the main Session Manager "interactive" shell.
     2                              <1> 
     3                              <1>     EXTERN sm$shlTOS
     4                              <1> 
     5                              <1> shellEntry:
     6                              <1> ;Entered with interrupts on.
     7 00000A09 488D25(00000000)    <1>     lea rsp, sm$shlTOS  ;Set/Reset internal shell stack! 
     8                              <1> ;And fall through to the main print loop
     9                              <1> shellMain:
    10                              <1> ;The shell main routine prints the number of sessions,
    11                              <1> ; the program names.
    12 00000A10 E825010000          <1>     call resetScreen
    13                              <1> ;Printing the screen header!
    14 00000A15 488D15(85030000)    <1>     lea rdx, ttlStr
    15 00000A1C E86A010000          <1>     call puts
    16 00000A21 488D15(9E020000)    <1>     lea rdx, sessStr
    17 00000A28 E85E010000          <1>     call puts
    18 00000A2D 8B15(28000000)      <1>     mov edx, dword [dMaxSesIndx]    ;This is also number of USER sessions
    19 00000A33 FFC2                <1>     inc edx     ;Add 1 to include the SM session
    20 00000A35 80C230              <1>     add dl, "0" ;Convert to ASCII char
    21 00000A38 E846010000          <1>     call putch
    22 00000A3D E851010000          <1>     call putNewline
    23 00000A42 488D15(4D020000)    <1>     lea rdx, uline
    24 00000A49 E83D010000          <1>     call puts
    25 00000A4E E840010000          <1>     call putNewline
    26                              <1> ;Printing the sessions.
    27 00000A53 B230                <1>     mov dl, "0"
    28 00000A55 E829010000          <1>     call putch
    29 00000A5A 488D15(E6020000)    <1>     lea rdx, colonStr
    30 00000A61 E825010000          <1>     call puts
    31 00000A66 488D15(42030000)    <1>     lea rdx, sesManStr
    32 00000A6D E819010000          <1>     call puts
    33 00000A72 E81C010000          <1>     call putNewline
    34                              <1> ;Now we print the name from each session's current PSP environment pointer.
    35 00000A77 B901000000          <1>     mov ecx, 1  ;Start from this session number
    36                              <1> .printLp:
    37 00000A7C 89CA                <1>     mov edx, ecx
    38 00000A7E 80C230              <1>     add dl, "0" 
    39 00000A81 E8FD000000          <1>     call putch
    40 00000A86 488D15(E6020000)    <1>     lea rdx, colonStr
    41 00000A8D E8F9000000          <1>     call puts
    42 00000A92 488D15(32030000)    <1>     lea rdx, waitStr    ;Now print the state of the session
    43 00000A99 E8ED000000          <1>     call puts
    44                              <1>     
    45                              <1>     ;Now get the string to print
    46                              <1>     ;THIS NEEDS TO BE REPLACED AND CURRENTLY DOESN'T WORK!
    47                              <1>     ;call getPcbPtr ;Get the pcb ptr in rdi
    48                              <1>     ;mov rdx, qword [rdi + pcb.sdaCopy + sda.currentPSP]    ;Get the PSPptr
    49                              <1>     ;call getProcName    ;Get the process name ptr for process of PSP in rdx
    50                              <1>     ;jnc .nameFound
    51                              <1>     
    52 00000A9E 488D15(67030000)    <1>     lea rdx, noNameStr
    53 00000AA5 E8E1000000          <1>     call puts
    54 00000AAA EB1A                <1>     jmp short .nextSession
    55                              <1> .nameFound:
    56 00000AAC 4889D7              <1>     mov rdi, rdx    ;Copy the ptr here to get the len of the ASCIIZ string
    57 00000AAF 51                  <1>     push rcx        ;Save the number of the pcb we are at
    58 00000AB0 B812120000          <1>     mov eax, 1212h
    59 00000AB5 CD2F                <1>     int 2Fh
    60                              <1>     ;ecx now has the string length + terminating null
    61                              <1>     ;rdx points to the ASCIIZ string
    62 00000AB7 FFC9                <1>     dec ecx     ;Drop the terminating null
    63 00000AB9 BB01000000          <1>     mov ebx, 1  ;STDOUT
    64 00000ABE B800400000          <1>     mov eax, 4000h
    65 00000AC3 CD21                <1>     int 21h
    66 00000AC5 59                  <1>     pop rcx     ;Get back the pcb number
    67                              <1> .nextSession:
    68 00000AC6 E8C8000000          <1>     call putNewline
    69 00000ACB FFC1                <1>     inc ecx
    70 00000ACD 390D(28000000)      <1>     cmp dword [dMaxSesIndx], ecx   ;Keep going until dMaxSesIndx < ecx
    71 00000AD3 73A7                <1>     jae .printLp
    72                              <1> ;All printing done, now wait for input from user
    73 00000AD5 488D15(10030000)    <1>     lea rdx, helpStr
    74 00000ADC E8AA000000          <1>     call puts
    75 00000AE1 488D15(E9020000)    <1>     lea rdx, promptStr
    76 00000AE8 E89E000000          <1>     call puts
    77 00000AED 488D15(34000000)    <1>     lea rdx, inStr
    78 00000AF4 66C7020200          <1>     mov word [rdx], 0002h   ;Init the buffered string
    79 00000AF9 B8000A0000          <1>     mov eax, 0A00h  ;Await buffered input
    80 00000AFE CD21                <1>     int 21h
    81 00000B00 0FB64A02            <1>     movzx ecx, byte [rdx + 2]
    82 00000B04 80F93F              <1>     cmp cl, "?"
    83 00000B07 0F8403FFFFFF        <1>     je shellMain
    84 00000B0D 80F931              <1>     cmp cl, "1"
    85 00000B10 721C                <1>     jb badChoice
    86 00000B12 80F939              <1>     cmp cl, "9"
    87 00000B15 7717                <1>     ja badChoice
    88 00000B17 80E930              <1>     sub cl, "0"
    89 00000B1A 390D(28000000)      <1>     cmp dword [dMaxSesIndx], ecx
    90 00000B20 720C                <1>     jb badChoice
    91                              <1> swapScreen:
    92                              <1> ;Enact the swap to the new screen here!
    93                              <1> 
    94                              <1>     
    95                              <1> 
    96                              <1> ;Finish by signalling to DOSMGR that we are done!
    97 00000B22 B800840000          <1>     mov eax, 8400h  ;Release Timeslice and then loop up again!
    98 00000B27 CD2A                <1>     int 2Ah
    99 00000B29 E9DBFEFFFF          <1>     jmp shellEntry  ;Next instruction is a restart!
   100                              <1> 
   101                              <1> badChoice:
   102                              <1> ;Beep at the user and then reset the screen, show display!
   103 00000B2E B207                <1>     mov dl, 07h ;Beep at the user (Do I want to do that?)
   104 00000B30 E84E000000          <1>     call putch
   105 00000B35 E9D6FEFFFF          <1>     jmp shellMain
   106                              <1> resetScreen:
   107                              <1> ;Dirty Hack! Please just send the ANSI code and make the driver recognise
   108                              <1> ; that one ANSI code... Or do a less dirty hack and do what COMMAND.COM does.
   109                              <1> 
   110                              <1> ;Select segment zero which resets current screen w/o affecting frozen state!
   111 00000B3A 31F6                <1>     xor esi, esi    
   112 00000B3C B80C440000          <1>     mov eax, 440Ch
   113 00000B41 B943030000          <1>     mov ecx, 0343h      ;Screen Control/"Restore Segment"
   114 00000B46 CD21                <1>     int 21h
   115                              <1>     return
    13 00000B48 C3                  <2>  ret
   116                              <1> 
   117                              <1> ;Shell handy routines
   118                              <1> getProcName:
   119                              <1> ;Input: rdx -> PSP pointer to find the task name for!
   120                              <1> ;Output: CF=NC: rdx -> Points to ASCIIZ process name
   121                              <1> ;        CF=CY: rdx = 0, Process name not found
   122                              <1> ;
   123                              <1> ;Here we search for the double 00 and then check if it is 0001 and
   124                              <1> ; pass the ptr to the word after.
   125 00000B49 488B523E            <1>     mov rdx, qword [rdx + psp.envPtr]   ;Get the environement pointer
   126 00000B4D FA                  <1>     cli
   127 00000B4E 51                  <1>     push rcx
   128 00000B4F 31C9                <1>     xor ecx, ecx
   129 00000B51 B9FF7F0000          <1>     mov ecx, 7FFFh  ;Max environment size
   130                              <1> .gep0:
   131 00000B56 66813A0000          <1>     cmp word [rdx], 0   ;Zero word?
   132 00000B5B 740D                <1>     je short .gep1
   133 00000B5D 48FFC2              <1>     inc rdx         ;Go to the next byte
   134 00000B60 FFC9                <1>     dec ecx
   135 00000B62 75F2                <1>     jnz short .gep0
   136                              <1> .gep00:
   137                              <1>     ;Failure here if we haven't hit the double null by the end of 32Kb
   138 00000B64 59                  <1>     pop rcx
   139 00000B65 31D2                <1>     xor edx, edx    ;Turn it into null pointer
   140 00000B67 F9                  <1>     stc     ;Set CF
   141 00000B68 EB17                <1>     jmp short .exit ;Exit reenabling the interrupts!
   142                              <1> .gep1:
   143 00000B6A 4881C202000000      <1>     add rdx, 2  ;Skip the double null
   144 00000B71 66813A0100          <1>     cmp word [rdx], 1   ;Check if one more string in environment
   145 00000B76 75EC                <1>     jne .gep00
   146 00000B78 4881C202000000      <1>     add rdx, 2  ;Skip the 0001 word. Should always clear CF
   147 00000B7F 59                  <1>     pop rcx
   148 00000B80 F8                  <1>     clc     ;Clear CF
   149                              <1> .exit:
   150 00000B81 FB                  <1>     sti
   151                              <1>     return
    13 00000B82 C3                  <2>  ret
   152                              <1> putch:
   153 00000B83 B800020000          <1>     mov eax, 0200h
   154 00000B88 CD21                <1>     int 21h
   155                              <1>     return
    13 00000B8A C3                  <2>  ret
   156                              <1> puts:
   157 00000B8B B800090000          <1>     mov eax, 0900h
   158 00000B90 CD21                <1>     int 21h
   159                              <1>     return
    13 00000B92 C3                  <2>  ret
   160                              <1> putNewline:
   161 00000B93 488D15(4A020000)    <1>     lea rdx, newlineStr
   162 00000B9A E9ECFFFFFF          <1>     jmp puts
   163                              <1> 
   164                              <1> ;------------------------------------------------------------
   165                              <1> ;Default SM Int 22h Handler
   166                              <1> ;------------------------------------------------------------
   167                              <1> ;If this is ever executed, the session will enter a special 
   168                              <1> ; state where the user is prompted to type in the name of
   169                              <1> ; the program to launch in this session. 
   170                              <1> ;For now, it will simply try and relaunch a program.
   171                              <1> ;For for now, it will simply print a string and freeze.
   172                              <1> ;This will never happen as no COMMAND.COM can be exited
   173                              <1> ; with the defaults we have set up.
   174                              <1> i22hHdlr:
   175 00000B9F 488D15(ED010000)    <1>     lea rdx, sesFrozStr
   176 00000BA6 B800090000          <1>     mov eax, 0900h
   177 00000BAB CD21                <1>     int 21h
   178                              <1> .lp:
   179 00000BAD EBFE                <1>     jmp short .lp ;Enter an infinite loop
   180                              <1> 
   181                              <1> i22hShell:
   182                              <1> ;Simply reset the screen and print the info again!
   183 00000BAF E95CFEFFFF          <1>     jmp shellMain
   184                              <1> 
   185                              <1> i23hHdlr:
   186                              <1> ;Default i23 handler, relaunch the shell.
   187                              <1> ;Not doing so will reenter the call on a newline...
   188 00000BB4 F9                  <1>     stc
   189 00000BB5 C20800              <1>     ret 8
   190                              <1> i24hHdlr:
   191 00000BB8 B003                <1>     mov al, 3   ;Always FAIL
   192                              <1> interruptExit:  ;Used to overwrite Int 2Eh
   193 00000BBA 48CF                <1>     iretq
   194                              <1> 
    16                                  
    17                                  Segment dseg data private align=16
    18                                  %include "./src/data/smdata.asm"
     1                              <1> 
     2 00000000 434D443D            <1> cmdStr      db "CMD="   ;String to search for in the environment
     3 00000004 413A5C434F4D4D414E- <1> dfltShell   db "A:\COMMAND.COM",0 ;Default session shell string
     3 0000000D 442E434F4D00        <1>
     4 00000013 413A5C444F535C434F- <1> dfltShell2  db "A:\DOS\COMMAND.COM",0    ;Str2 is str1 not present
     4 0000001C 4D4D414E442E434F4D- <1>
     4 00000025 00                  <1>
     5 00000026 0A2F50202F453A3230- <1> cmdTail     db 10, "/P /E:2048",CR   ;Default command tail, ensure an environment!
     5 0000002F 34380D              <1>
     6                              <1> 
     7                              <1> 
     8                              <1> ;Static Error Strings 
     9 00000032 4572726F7220303030- <1> bvStr       db "Error 0001: Invalid DOS Version.",CR,LF,"$"
     9 0000003B 313A20496E76616C69- <1>
     9 00000044 6420444F5320566572- <1>
     9 0000004D 73696F6E2E0D0A24    <1>
    10 00000055 4572726F7220303030- <1> noConStr    db "Error 0002: Invalid Console Driver",CR,LF,"$"
    10 0000005E 323A20496E76616C69- <1>
    10 00000067 6420436F6E736F6C65- <1>
    10 00000070 204472697665720D0A- <1>
    10 00000079 24                  <1>
    11 0000007A 4572726F7220303030- <1> noScreenStr db "Error 0003: Not enough screens",CR,LF,"$"
    11 00000083 333A204E6F7420656E- <1>
    11 0000008C 6F7567682073637265- <1>
    11 00000095 656E730D0A24        <1>
    12 0000009B 4572726F7220303030- <1> noMemStr    db "Error 0004: Not enough memory to start Session Manager",CR,LF,"$"
    12 000000A4 343A204E6F7420656E- <1>
    12 000000AD 6F756768206D656D6F- <1>
    12 000000B6 727920746F20737461- <1>
    12 000000BF 72742053657373696F- <1>
    12 000000C8 6E204D616E61676572- <1>
    12 000000D1 0D0A24              <1>
    13 000000D4 4572726F7220303030- <1> noCmdStr    db "Error 0005: Default command interpreter not found",CR,LF,"$"
    13 000000DD 353A2044656661756C- <1>
    13 000000E6 7420636F6D6D616E64- <1>
    13 000000EF 20696E746572707265- <1>
    13 000000F8 746572206E6F742066- <1>
    13 00000101 6F756E640D0A24      <1>
    14 00000108 4572726F7220303030- <1> noExecStr   db "Error 0006: Unable to start up session",CR,LF,
    14 00000111 363A20556E61626C65- <1>
    14 0000011A 20746F207374617274- <1>
    14 00000123 207570207365737369- <1>
    14 0000012C 6F6E0D0A            <1>
    15 00000130 202020202020202020- <1>             db "            It is recommended you restart your machine...",CR,LF,"$"
    15 00000139 202020497420697320- <1>
    15 00000142 7265636F6D6D656E64- <1>
    15 0000014B 656420796F75207265- <1>
    15 00000154 737461727420796F75- <1>
    15 0000015D 72206D616368696E65- <1>
    15 00000166 2E2E2E0D0A24        <1>
    16 0000016C 4572726F7220303030- <1> noIOCTLStr  db "Error 0007: Generic IOCTL error",CR,LF,"$"
    16 00000175 373A2047656E657269- <1>
    16 0000017E 6320494F43544C2065- <1>
    16 00000187 72726F720D0A24      <1>
    17 0000018E 4572726F7220303030- <1> noStdinStr  db "Error 0008: STDIN Redirected from CON device",CR,LF,"$"
    17 00000197 383A20535444494E20- <1>
    17 000001A0 526564697265637465- <1>
    17 000001A9 642066726F6D20434F- <1>
    17 000001B2 4E206465766963650D- <1>
    17 000001BB 0A24                <1>
    18 000001BD 4572726F7220303030- <1> noStdoutStr db "Error 0009: STDOUT Redirected from CON device",CR,LF,"$"
    18 000001C6 393A205354444F5554- <1>
    18 000001CF 205265646972656374- <1>
    18 000001D8 65642066726F6D2043- <1>
    18 000001E1 4F4E20646576696365- <1>
    18 000001EA 0D0A24              <1>
    19                              <1> 
    20 000001ED 0D0A53657373696F6E- <1> sesFrozStr  db CR,LF,"Session Frozen",CR,LF,"$"
    20 000001F6 2046726F7A656E0D0A- <1>
    20 000001FF 24                  <1>
    21                              <1> 
    22                              <1> ;Here we put the DOSMGR fatal error strings
    23 00000200 0D0A466174616C2045- <1> fatalStr    db CR,LF, "Fatal Error: $"
    23 00000209 72726F723A2024      <1>
    24 00000210 556E696E7465727275- <1> badLockStr  db "Uninterruptable Critical Lock interrupted$"
    24 00000219 707461626C65204372- <1>
    24 00000222 69746963616C204C6F- <1>
    24 0000022B 636B20696E74657272- <1>
    24 00000234 757074656424        <1>
    25 0000023A 0D0A53797374656D20- <1> sysHltStr   db CR,LF,"System Halted$"
    25 00000243 48616C74656424      <1>
    26                              <1> 
    27                              <1> ;Shell Strings
    28 0000024A 0D0A24              <1> newlineStr  db CR,LF,"$"
    29 0000024D 2D2D2D2D2D2D2D2D2D- <1> uline       db 80 dup ("-"),"$"
    29 00000256 2D2D2D2D2D2D2D2D2D- <1>
    29 0000025F 2D2D2D2D2D2D2D2D2D- <1>
    29 00000268 2D2D2D2D2D2D2D2D2D- <1>
    29 00000271 2D2D2D2D2D2D2D2D2D- <1>
    29 0000027A 2D2D2D2D2D2D2D2D2D- <1>
    29 00000283 2D2D2D2D2D2D2D2D2D- <1>
    29 0000028C 2D2D2D2D2D2D2D2D2D- <1>
    29 00000295 2D2D2D2D2D2D2D2D24  <1>
    30 0000029E 202020202020202020- <1> sessStr     db 9 dup (SPC), "Current Sessions", 29 dup (SPC)
    30 000002A7 43757272656E742053- <1>
    30 000002B0 657373696F6E732020- <1>
    30 000002B9 202020202020202020- <1>
    30 000002C2 202020202020202020- <1>
    30 000002CB 202020202020202020  <1>
    31 000002D4 4E756D626572206F66- <1> numSesStr   db "Number of sessions"
    31 000002DD 2073657373696F6E73  <1>
    32 000002E6 3A2024              <1> colonStr    db ": $"
    33                              <1> 
    34 000002E9 456E74657220796F75- <1> promptStr   db "Enter your desired session number...> $"
    34 000002F2 722064657369726564- <1>
    34 000002FB 2073657373696F6E20- <1>
    34 00000304 6E756D6265722E2E2E- <1>
    34 0000030D 3E2024              <1>
    35 00000310 0D0A0A537472696B65- <1> helpStr     db CR,LF,LF,"Strike ? to reset the screen",CR,LF,"$"
    35 00000319 203F20746F20726573- <1>
    35 00000322 657420746865207363- <1>
    35 0000032B 7265656E0D0A24      <1>
    36                              <1> ;Session default process names
    37 00000332 5B576169745D2024    <1> waitStr     db "[Wait] $"
    38 0000033A 5B457869745D2024    <1> deadStr     db "[Exit] $"
    39 00000342 5B52756E5D20205343- <1> sesManStr   db "[Run]  SCP/DOS Session Manager Shell$"
    39 0000034B 502F444F5320536573- <1>
    39 00000354 73696F6E204D616E61- <1>
    39 0000035D 676572205368656C6C- <1>
    39 00000366 24                  <1>
    40 00000367 53455353494F4E2053- <1> noNameStr   db        "SESSION SHELL (COMMAND.COM ?)$"
    40 00000370 48454C4C2028434F4D- <1>
    40 00000379 4D414E442E434F4D20- <1>
    40 00000382 3F2924              <1>
    41 00000385 202020202020202020- <1> ttlStr      db 28 dup (SPC), "SCP/DOS Session Manager",CR,LF,LF,"$"
    41 0000038E 202020202020202020- <1>
    41 00000397 202020202020202020- <1>
    41 000003A0 205343502F444F5320- <1>
    41 000003A9 53657373696F6E204D- <1>
    41 000003B2 616E616765720D0A0A- <1>
    41 000003BB 24                  <1>
    19                                  
    20                                  Segment bseg bss public align=16
    21                                  %include "./src/data/smbss.asm"
     1                              <1> ;Uninitialised data goes here
     2                              <1> 
     3                              <1> ;Write Once variables, ALL SET UP.
     4 00000000 ????????????????    <1> pDosMgrPsp  dq ?    ;Pointer to the DOSMGR PSP
     5 00000008 ????????????????    <1> pDosSda     dq ?    ;Pointer to the DOS SDA
     6 00000010 ????????            <1> dSdaLenMin  dd ?    ;Length of SDA that needs to be swapped if not in DOS.
     7 00000014 ????????            <1> dSdaLen     dd ?    ;Full SDA length
     8 00000018 ????????????????    <1> pPcbTbl     dq ?    ;Ptr to the first PCB SOTH.
     9 00000020 ????????            <1> dPcbLen     dd ?    ;Length of each pcb
    10 00000024 ????????            <1> dMaxTask    dd ?    ;Var version of MAX_TASK
    11 00000028 ????????            <1> dMaxSesIndx dd ?    ;Maximum screen session index! Max Session number = 7.
    12                              <1> 
    13                              <1> ;The below is a temp var until we make a good routine for if the 
    14                              <1> ; top level program of a session exits
    15 0000002C ????????????????    <1> pCmdShell   dq ?    ;Pointer to the command shell to launch
    16                              <1> 
    17                              <1> ;Shell to launch on sessions. 
    18                              <1> ;Read from the CMD= string in the environment or passed by cmd line argument.
    19 00000034 ??????????          <1> inStr       db 5 dup (?)
    20                              <1> ;newShell    db 67 dup (?) 
    21                              <1> 
    22                              <1> ;Dynamic variables below
    23                              <1> 
    24                              <1> ;Screen Session management data
    25 00000039 ??                  <1> bCurScrNum  db ?    ;Contains the current screen number!
    26 0000003A ??                  <1> bScrnIoOk   db ?    ;Set if the screen can be IO'ed to/from! Used by CON!
    27                              <1> 
    28 0000003B ??                  <1> bSM_Req     db ?    ;If set, the byte below indicates the requested screen
    29 0000003C ??                  <1> bSM_Req_Scr db ?    ;Screen number to swap to
    30                              <1> 
    31                              <1> ;Thread management
    32 0000003D ????????            <1> hCurPtda    dd ?    ;Current Thread Handle
    33 00000041 ????????????????    <1> pCurPtda    dq ?    ;Ptr to the current thread ptda.
    34                              <1> 
    35                              <1> ;Supported Critical section locks
    36 00000049 <res Ch>            <1> dosLock     db critLock_size dup (?)    ;Critical section lock
    37 00000055 <res Ch>            <1> drvLock     db critLock_size dup (?)    ;Critical section lock
    38                              <1> 
    39                              <1> ;List pointers
    40 00000061 ????????????????    <1> pObjTblHdr  dq ?    ;Pointer to the first system object table.
    41                              <1> ;The sleep list is a linked list of ptdas
    42 00000069 ????????????????    <1> pHdSlpList  dq ?    ;Ptr to the head of the sleep list (of ptdas)
    43                              <1> 
    44                              <1> schedBlk:   ;The schedule list block
    45 00000071 <res 280h>          <1>     db NUM_SCHED*schedHead_size dup (?)
    46                              <1> 
    47                              <1> ;BIOS related stuff
    48                              <1> pIDT:
    49 000002F1 ????                <1>     .limit  dw ?
    50 000002F3 ????????????????    <1>     .base   dq ?
    51                              <1> 
    52                              <1> ;Timer variables
    53 000002FB ??                  <1> bSliceCnt   db ?    ;Number of ticks since last swap
    54 000002FC ??                  <1> bSliceSize  db ?    ;Number of ticks in one "timeslice"
    55 000002FD ??                  <1> bTimerCnt   db ?    ;BIOS timer tracker (when it hits 55ms, do BIOS).
    56 000002FE ????????????????    <1> pOldTimer   dq ?
    22                                  
    23                                  Segment sseg$int bss stack align=16
    24                                  ;This is the interrupt handlers' default stack. Only used during 
    25                                  ; session swaps so it is ok (Interrupts are off).
    26 00000000 <res 100h>                  dq 20h dup (?)   ;32 qword stack is fine for this!
    27                                  Segment sseg$shl bss stack align=16
    28 00000000 <res 1000h>                 dq 200h dup (?)  ;Total 4K stack is fine
    28          ------------------       info: assembly required 1+3+2 passes

